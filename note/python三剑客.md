jupyter快捷键：

D,D（快速按俩个D）：删除单元格

shift+enter：执行当前单元格，并把光标移到下一单元格

ctrl+enter：执行当前单元格，但光标不会移到下一单元格

Esc：从编辑模式变成命令模式

回车：从命令模式变成编辑模式

【按N+H可以看到全部快捷键】

# python数据分析入门

## 1.python基础语法

### 1.1常用数据类型

1. 字符串

   - 字符串使用引号来定义，且单引号与双引号是等价的

   - 三引号用来输入包含多行文字的字符串

   - 字符串的加法：即字符串的拼接

   - 字符串索引：从0开始

   - 字符串的分隔：`字符串.split(分隔符)` 【把字符串分隔成多个子字符串，并存入到列表中返回】 

     （如果不写入分隔符，则默认以空格来对字符串进行分隔）

   - 查看字符串的长度：`len(字符串)`

2. 整数

3. 浮点数

4. 布尔值

5. 空值：None

### 1.2运算符

1. 算术运算符（+  -  *  /  //  %    **  ）
2. 比较运算符[==   !=   <>(不等于，与!=类似)    >   <   >=   <=]
3. 赋值运算符（=   +=  -=   *=    /=     %=    **=     //=）
4. 逻辑运算符[  and，or，not（取反）]
5. 成员资格运算符（in, not in）

### 1.3数据结构

- 列表、元组、字典、集合

### 1.4可变对象和不可变对象

可变对象：可以对其进行插入、删除等操作

不可变对象：不可以对其进行有改变的操作

[列表、字典、集合都是可变的，元组、字符串、整型都是不可变的]

### 1.5类型转换

`int()`    `float()`   `list()`    ........

### 1.6判断和循环

### 1.7列表生成式

## 2.python函数

### 2.1内置函数

`min()`  `max()`    `sum()`  等等

### 2.2自定义函数

使用def关键字

return返回特定的值（如果省略，则返回None）

如果传入参数的数目与实际不相符，会报错：所以也可以在函数定义时给参数设定默认值。

一个参数可以返回多个返回值（）



# python数据分析之Numpy

> NumPy(Numeric Python)是Python的一种开源的数值计算扩展，是python的一个第三方库。这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表结构要高效的多。NumPy提供了许多高级的数值编程工具。Numpy的一个重要特性是它的数组计算，是我们做数据分析必不可少的一个包。

导入python库使用关键字**import**，后面可以自定义库的简称，但是一般都将Numpy命名为np，pandas命名为pd。

使用前一定要先导入Numpy包，导入的方法有以下几种：

```python
import numpy
import numpy as np   # 推荐写法
from numpy import *  # 不是很建议这种写法，因为使用函数时不用加前缀的话有可能会与其他函数名称起冲突，可能会导致报错
```



## 1.Numpy的数组对象

### 1.1数组上的数学操作

引入：


```python
# 假设我们想将列表中的每个元素增加1，但列表不支持这样的操作：
a = [1,2,3,4]
# 想让每个元素都加一：a+1 #报错
# 要用列表生成式
[x+1 for x in a]  # [2, 3, 4, 5]

b = [2,3,4,5]
# 想要与另一个数组相加，得到对应元素相加的结果：
a+b #并不是我们想要的结果，只是列表的拼接：[1, 2, 3, 4, 2, 3, 4, 5]
# 需要利用到列表生成式：
[x+y for(x,y) in zip(a,b)]  # [3, 5, 7, 9]
```

这样的操作比较麻烦，而且在数据量特别大的时候会非常耗时间。如果使用Numpy，就会变得特别简单：


```python
import numpy as np   # 导入numpy包
a = np.array([1,2,3,4])
a # [1 2 3 4]
a+1 # [2 3 4 5]
a*2 # [2, 4, 6 8]

b = np.array([2,3,4,5])
a + b # [3 5 7 9]
```



### 1.2生成数组的方法

- 从列表产生数组：（最基本的方法）
  ```python
  l = [0,1,2,3]
  a = np.array(l)
  a  # [0 1 2 3]
  ```

- 从列表传入：
  ```python
  a = np.array([1,2,3,4])
  a # [1 2 3 4]
  ```

- 生成全0数组：
  ```python
  np.zeros(n) #括号内传的n为要生成的数组元素的个数，默认为浮点数
  ```
  ```python
  # eg：
  np.zeros(5)  # [0. 0. 0. 0. 0.]
  ```

- 生成全1的数组：
  ```python
  np.ones(n) #括号内传的n为要生成的数组元素的个数，默认浮点数
  ```
  ```python
  # eg：
  np.ones(5)  # [1. 1. 1. 1. 1.]
  ```


- 可以用`dtype = 想要的类型`来自己指定数据类型（int, bool...）

  ```python
  # eg:
  np.ones(5, dtype=bool) # 结果：[ True  True  True  True  True]
  np.zeros(5, dtype=int) # 结果：[0 0 0 0 0]
  ```

- 可以使用 fill 方法将数组设为指定值（让数组中的每一个元素都为指定值）

  语法：`数组.fill(要设置的指定值)`

  注意：

  - 数组中要求**所有元素的dtype(数据类型)都必须要是一样的**【与列表不同】
  - 如果传入参数的类型与数组类型不一样，会自动按照已有的类型进行转换。【如果就是想要将数组中的元素换成与原来的数组元素的类型不同时，可以用stype方法进行强制类型转换】

- stype强制将数组元素类型转换

  语法：`数组 = 数组.stype(要转换成的数据类型)`


```python
# eg：
import numpy as np   # 导入numpy包
a = np.array([1, 2, 3, 4])
print(a)  # [1 2 3 4]
a.fill(5)  # 让数组中的每一个元素都为5
print(a)  # [5 5 5 5]
a.fill(2.5)
print(a)  # [2 2 2 2]  # 会自动进行取整
a = a.astype('float')
a.fill(2)
print(a)  # [2. 2. 2. 2.]
a.fill(2.5)
print(a)  # [2.5 2.5 2.5 2.5]
```
- 还可以使用一些特定的方法生成特殊的数组

  - 用arange生成从某个数开始的序列：

    语法：`np.arange([起始数，]终点数[,步长])` 

    [与range的使用方法类似，但range的步长不支持小数]
  
    - 一个参数时，参数值为终点，起点取默认值0，步长取默认值1
  
    - 两个参数时，第一个参数为起点，第二个参数为终点，步长取默认值1。包前不包后【实际上是左闭右开(在终点数处结束但不包含它本身)】
    - 三个参数时，第一个参数为起点，第二个参数为终点，第三个参数为步长；步长支持小数。
  
    ```python
    a = np.arange(1,10) # 生成从1-9的一个整数序列
    print(a) # [1 2 3 4 5 6 7 8 9]
    b = np.arrang(1,10,2) # 步长为2
    print(b) # [1 3 5 7 9]
    c = np.arange(1.3, 10)
    print(c)  # [1.3 2.3 3.3 4.3 5.3 6.3 7.3 8.3 9.3]
    d = np.arange(1, 5, 1.5)
    print(d)  # [1.  2.5 4. ]
    ```
  
  - 生成等差数列：
  
    `linspace(起点，终点，元素个数)`  【<u>终点数是包括在内的</u>（左闭**右闭**）】
  
    ```python
    # eg:
    a = np.linspace(1, 5, 11)
    print(a)  # [1.  1.4 1.8 2.2 2.6 3.  3.4 3.8 4.2 4.6 5. ]
    ```
  
  - 生成随机数
  
    - 返回在0-1范围内的n个随机浮点数
  
      语法：`np.random.rand(需要的随机数的个数n)`   
  
    - 返回n个服从标准正态分布的随机浮点数
  
      [ 标准正态分布又称为u分布，是以0为均值、以1为标准差的正态分布，记为N（0，1）]
  
      语法：`np.random.randn(需要的随机数的个数n)`   
  
    - 返回n个从起点到终点的随机整数
  
      语法：`np.random.randint(起点，终点，需要的随机数的个数n)`  【<u>终点数是不包括在内的</u>（左闭右开）】
  
      > - 在python中：random.randint(a,b)：用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n：a<=n<=b,即[a,b]。
      >
      >   如：m=random.randint(0,3)它只会在0、1、2、3中随机返回一个整数
      >
      > - 在numpy中：np.random.randint(a,b)：用于生成一个指定范围内的整数。其中参数a是下限，参数b是上限，生成的随机数n：a<=n<b,即[a,b)。
      >
      >   如：numpy.random.randint(0,3)会在0、1、2中随机返回一个整数，但是其中不会包括3。
  
    ```python
    np.random.rand(5)  # [0.75380372 0.44891155 0.43189469 0.633356   0.01367505] 
    np.random.randn(5) #标准正态分布# [ 0.31446483 -1.02828074  0.35086322  0.18106916 -0.07317298]
    np.random.randint(1,10,5) #生成随机整数，从1-19中随机10个# [5 9 9 8 4]
    ```
  
    - 创建多维随机数组
    
      语法：`np.random.random((第一维元素个数，第二维元素个数，...))`
    
      注意：`np.random.random()`中的"( )"里面要用( )把每一维的元素个数包括到一个元组中。否则报错
    
      ```python
      # eg:
      # 会报错：a = np.random.random(3, 4)
      a = np.random.random((3, 4))
      print(a)
      # [[0.31314274 0.27400047 0.26432628 0.98058422] [0.23238729 0.26398298 0.09495022 0.31992298] [0.84497553 0.02284272 0.26811946 0.97573487]]
      b = np.random.random((3, 4, 2))
      print(b)
      ```
    
    - 创建指定范围的整数元素的多维随机数组
    
      语法：`np.random.randint(起点，终点，(第一维的元素数目，第二维的元素数目，...))`
    
      【左闭右开，终点不包括在内】
    
    - 创建元素是服从标准正态分布的随机浮点数的多维随机数组
    
      语法：`np.random.randn((第一维的元素数目，第二维的元素数目，...))`
    
      

### 1.3数组的属性

- 用type查看变量类型

  语法：`type(变量名称)`

- 用dtype查看数组中的元素的数据类型

  语法：`数组名.dtype`

- 用shape查看数组的形状（会返回一个元组，每个元素代表每一维的元素数目）

  - 方法一：`数组名.shape`
  - 方法二：`np.shape(数组名)`

- 用size来查看数组里面总的元素的个数

  语法：`数组名.size`

- 用ndim查看数组的维度

  语法：`数组名.ndim`


```python
import numpy as np   # 导入numpy包
a = np.array([1, 2, 3, 4, 5])
print(type(a))  # <class 'numpy.ndarray'>(a的类型是numpy的n维数组)
print(a.dtype)  # int32
print(a.shape)  # (5,)
print(np.shape(a))  # (5,)
print(a.size)  # 5
print(a.ndim)  # 1
```

（多维的在后面）



### 1.4索引和切片

索引某个元素：`数组名[下标]`  【下标从0开始】

修改某个元素的值：`数组名[下标] = 要修改到的值`

切片操作：`数组名[起点：终点：步长]` 【左闭右开】 (支持负索引)（参数可省）


```python
a = np.array([0,1,2,3])
a[0]  # 0 #索引
a[0] = 10  # 修改元素值
print(a)  # [10 1 2 3]

# 切片
b = np.array([11,12,13,14,15])
b[1:3] #左闭右开，从0开始算
b[1:-2] #等价于a[1:3]
b[-4:3] #等价与a[1:3]
# 上面3个的结果都是：[12 13]
b[1:4:2] # 结果：[12 14]
b[-2:] #从倒数第2个取到最后。结果：[14 15]
b[::2] #从头取到尾，间隔2，结果：[11 13 15]
```



### 1.5多维数组及其属性

array还可以用来生成多维数组:

（如果传入的是一个以列表为元素的列表，最终得到一个二维数组。）

（查看其属性的方法与一维数组类似）


```python
b = np.array([[1, 2, 3], [3, 4, 5]])
# 查看b的类型：
print(type(b))  # <class 'numpy.ndarray'>  （numpy的n维数组)
# 查看数组中的元素的数据类型：
print(b.dtype)  # int32
# 查看形状：
print(b.shape)  # (2, 3)
print(np.shape(b))  # (2, 3)
# 查看总的元素个数：
print(b.size)  # 6
# 查看维数：
print(b.ndim)  # 2
```



### 1.6多维数组索引

- 对于二维数组，可以传入两个数字来索引：`数组名[在第一维的下标（行索引），在第二维的下标（列索引）]`

- 还可利用索引修改某个元素的值：`数组名[在第一维的下标（行索引），在第二维的下标（列索引）] = 要修改到的值`

- 还可以使用单个索引来索引一整行内容：`数组名[在第一维的下标(行索引)]` 

- 索引一整列内容:`数组名[: , 列索引]`


```python
# 索引
a = np.array([[0,  1,  2,  3], [10, 11, 12, 13]])
print(a[1, 2])  #12 # 其中，1是行索引，2是列索引。事实上，Python会将它们看成一个元组（1,2），然后按照顺序进行对应。
# 利用索引修改元素的值
a[1,2] = -1 
print(a)  # [[ 0  1  2  3] [10 11 -1 13]]
# 使用单个索引来索引一整行内容:
print(a[1])  # [10 11 -1 13]
# 索引一整列内容：
print(a[:,1])  # 1是指第二列，冒号左右两边都省略  # 结果：[1 11]
```



【“不完全”索引 ：只给定行索引的时候，而不给定列索引时返回整行】：


```python
a = np.array([[0, 1, 2, 3, 4, 5],
              [10, 11, 12, 13, 14, 15],
              [20, 21, 22, 23, 24, 25],
              [30, 31, 32, 33, 34, 35],
              [40, 41, 42, 43, 44, 45],
              [50, 51, 52, 53, 54, 55]])
# 返回一条次对角线上的5个值:
print(a[:3])  # [[ 0  1  2  3  4  5] [10 11 12 13 14 15] [20 21 22 23 24 25]]
# 也可以使用布尔数组来花式索引取出第2,3,5行：
con = np.array([0, 1, 1, 0, 1, 0], dtype=bool)
print(a[con])  # [[10 11 12 13 14 15] [20 21 22 23 24 25] [40 41 42 43 44 45]]
```



### 1.7多维数组切片操作

每一维都支持切片的规则，支持负索引，lower、upper、step都可省略。

`[lower:upper:step]`


```python
# eg：
a = np.array([[0, 1, 2, 3, 4, 5],
              [10, 11, 12, 13, 14, 15],
              [20, 21, 22, 23, 24, 25],
              [30, 31, 32, 33, 34, 35],
              [40, 41, 42, 43, 44, 45],
              [50, 51, 52, 53, 54, 55]])
# 想得到第一行的第4和第5两个元素：
print(a[0, 3:5])  # [3 4]
# 得到最后两行的最后两列：
print(a[4:, 4:])  # [[44 45] [54 55]]
print(a[-2:, -2:])  # # [[44 45] [54 55]]
# 得到第三列：
print(a[:, 2])  # [ 2 12 22 32 42 52]
# 取出3,5行的奇数列：
a[2::2,::2] # [[20 22 24] [40 42 44]]
```

-----

注意：**切片**在内存中使用的是**引用**机制，也就是说：python不会给切片操作后得到的子数组来分配一个新的存储空间，而是让得到的数组与原来的数组指向了同一个空间（原来数组本来所在的内存空间）。因此，改变其中一个数组的值时，另一个数组的值也会跟着发生同样的改变。


```python
# eg：
a = np.array([0,1,2,3,4])
b = a[2:4]
print(b) # [2 3]
# 引用机制意味着，Python并没有为b分配新的空间来存储它的值，而是让b指向了a所分配的内存空间，因此，改变b时会改变a的值：
b[0] = 10
print(a)  # [0 1 10 3 4]
```

> 而这种现象在列表中并不会出现：
>
>
> ```python
> # eg：
> a = [1,2,3,4,5]
> b = a[2:4]
> b[0] = 10
> print(a)  # [1, 2, 3, 4, 5]
> ```

- 切片在内存中使用引用机制: 


  优点：对于很大的数组，不用大量复制多余的值，节约了空间。

  缺点：可能出现改变一个值改变另一个值的情况。

—>>解决方法：使用`copy()`方法来进行复制，复制就会申请新的内存，那对它进行值的改动就不会影响到原来的数组：


```python
# eg：
a = np.array([0,1,2,3,4])
b = a[2:4].copy()
b[0] = 10
print(a)  # [0 1 2 3 4]  （没有改变）
```



### 1.8花式索引 

切片只能支持连续或者等间隔的切片操作，要想实现任意位置的操作，就需要使用花式索引。

**注意**：与切片不同，花式索引返回的是原对象的一个**复制**而不是引用。



#### 1.8.1一维花式索引 


```python
# eg:
a = np.arange(0,100,10) # 可以使用arange函数来产生等差数组
print(a)  # [1 10 20 30 40 50 60 70 80 90]
```

花式索引需要指定索引位置：


```python
index = [1,2,-3]
y = a[index]
print(y) # [10 20 70]
```


还可以使用布尔数组来花式索引：


```python
mask = np.array([0, 2, 2, 0, 0, 1, 0, 0, 1, 0], dtype = bool)
print(mask) # [False  True  True False False  True False False  True False]
```

必须要是**布尔数组**，且布尔数组（在这里是mask）的长度**必须**与要操作的数组（在这里是a）**长度相等**，才能使用布尔数组来进行花式索引，取出为true的位置上的元素。


```python
print(a[mask])  # [10 20 50 80]
```



#### 1.8.2二维花式索引 


```python
a = np.array([[0, 1, 2, 3, 4, 5],
              [10, 11, 12, 13, 14, 15],
              [20, 21, 22, 23, 24, 25],
              [30, 31, 32, 33, 34, 35],
              [40, 41, 42, 43, 44, 45],
              [50, 51, 52, 53, 54, 55]])
# 给定行和列的值：
# 返回一条次对角线上的5个值:
print(a[(0, 1, 2, 3, 4), (1, 2, 3, 4, 5)])  # [ 1 12 23 34 45]
# 返回最后3行第1、3、5列的数据：(方法有多种)
print(a[-3:, ::2])  # [[30 32 34] [40 42 44] [50 52 54]]
print(a[3:, (0, 2, 4)])  # [[30 32 34] [40 42 44] [50 52 54]]
print(a[3:, [0, 2, 4]])  # [[30 32 34] [40 42 44] [50 52 54]]

# 也可以利用布尔数组进行花式索引：
mask = np.array([0, 0, 0, 1, 1, 1], dtype=bool)
print(a[mask, ::2])  # [[30 32 34] [40 42 44] [50 52 54]]
```



### 1.9where语句

`np.where(数组)`：where函数会返回数组中所有非零（"真"的）元素的**索引**

`np.where(要返回的索引位置处的数组元素要满足的条件)`：where函数返回的是，满足where函数条件的数组元素的具体**索引**位置。

（where的返回值是一个元组）


```python
# eg：
a = np.array([0, 12, 5, 20])
# 判断数组中的元素是不是大于10：
print(a > 10)  # [False  True False  True]
# 数组中所有大于10的元素的索引位置：
print(np.where(a > 10))  # (array([1, 3], dtype=int64),)
# 注意到where的返回值是一个元组，返回的是索引位置
```

------

- 也可以直接用数组操作：

  语法：`数组名[要返回的数组元素要满足的条件]`


```python
a = np.array([0, 12, 5, 20])
print(a[np.where(a > 10)])  # [12 20]
print(a[a > 10])  # [12 20]
```



## 2.数组类型 

| **基本类型** | **可用的Numpy类型**                      | **备注**                                         |
| :----------- | :--------------------------------------- | :----------------------------------------------- |
| 布尔型       | bool                                     | 占一个字节                                       |
| 整型         | int8,int16,int32,int64,int128,int        | int跟C语言中long一样大                           |
| 无符号整型   | uint8,uint16,uint32,uint64,uint128,uint  | uint跟C语言中的unsigned long一样大               |
| 浮点数       | float16,float32,float                    | 默认为双精度float64，longfloat精度大小与系统有关 |
| 复数         | complex64,complex128,complex,longcomplex | 默认为complex128,即实部虚部都为双精度            |
| 字符串       | string,unicode                           | 可以使用dtype=S4表示一个4字节字符串的数组        |
| 对象         | object                                   | 数组中可以使用任意值                             |
| 时间         | datetime64,timedelta64                   |                                                  |

### 转换元素的类型的方法

- dtype


```python
a = np.array([1.5,-3],dtype = float)
print(a)  # [1.5 -3.]
```



- asarray 函数 

可以通过asarray函数来对数组元素的类型来做调整


```python
a = np.array([1, 2, 3])
print(np.asarray(a, dtype=float))  # [1. 2. 3.]
```



- astype方法

astype 方法返回一个**新数组**，而不是使用引用地址。所以，对返回的这个新数组做任何的改动都不会影响到原来的数组：


```python
a = np.array([1, 2, 3])
b = a.astype(float)
print(b) # [1. 2. 3.]
b[0] = 0.5
print(b)  # [0.5 2. 3.]
print(a)  # [1 2 3]
# a本身并没有发生任何变化--拷贝
```



## 3.数组操作 

以豆瓣10部高分电影为例 


```python
# 电影名称
mv_name = ["肖申克的救赎","控方证人","美丽人生","阿甘正传","霸王别姬","泰坦尼克号","辛德勒的名单","这个杀手不太冷","疯狂动物城","海豚湾"]
# 评分人数
mv_num = np.array([692795,42995,327855,580897,478523,157074,306904,662552,284652,159302])
# 评分
mv_score = np.array([9.6,9.5,9.5,9.4,9.4,9.4,9.4,9.3,9.3,9.3])
# 电影时长（分钟）
mv_length = np.array([142,116,116,142,171,194,195,133,109,92])
```

### 数组排序

#### sort函数

语法: `np.sort(要排序的数组对象)`

注意：排序后<u>原来数组里面元素的顺序不会变</u>，只是会返回一个原数组排序后得到的**新数组**


```python
print(np.sort(mv_num))  # [ 42995 157074 159302 284652 306904 327855 478523 580897 662552 692795]
# sort不改变原来数组元素的顺序:
print(mv_num)  # [692795  42995 327855 580897 478523 157074 306904 662552 284652 159302]
```

tips：将数组逆序可用：`数组[::-1]`



#### argsort函数 

返回在原来数组中从小到大的排列的数组元素的**索引位置**。【常常会用于索引其他数组的元素】

语法: `np.argsort(要排序的数组对象)`


```python
order = np.argsort(mv_num)
print(order)  # [1 5 9 8 6 2 4 3 7 0]
# 评分人数最少的电影名称
print(mv_name[order[0]])  # 控方证人
# 评分人数最多的电影名称
print(mv_name[order[-1]]) # 肖申克的救赎
```



### 求和 

方法1：`np.sum(要求和的数组对象)`

方法2：`要求和的数组对象.sum()`


```python
np.sum(mv_num)  # 3693549
mv_num.sum()  # 3693549
```



### 最大值 

方法1：`np.max(要最大值的数组对象)`

方法2：`要求最大值的数组对象.max()`


```python
np.max(mv_length)  # 195
mv_length.max() # 195
```



### 最小值 

方法1：`np.mim(要最小值的数组对象)`

方法2：`要求最小值的数组对象.mim()`


```python
np.min(mv_score)
mv_score.min()  # 9.3
```



### 均值 

方法1：`np.mean(要求均值的数组对象)`

方法2：`要求均值的数组对象.mean()`


```python
np.mean(mv_length)
mv_length.mean() # 141.0
```



### 标准差 （方差）

方法1：`np.std(要求标准差的数组对象)`

方法2：`要求标准差的数组对象.std()`


```python
np.std(mv_length)
mv_length.std() # 33.713498780162226
```



### 相关系数矩阵 

看两个数组的相关系数矩阵

语法：`np.cov(数组1，数组2)`


```python
np.cov(mv_score,mv_length) # [[9.88888889e-03 4.55555556e-01] [4.55555556e-01 1.26288889e+03]]
```



## 4.多维数组操作 

### 4.1数组形状 

- shape方法
  - 访问数组形状：`数组.shape`
  - 修改数组形状：`数组.shape = (第一维的元素数目，第二维的元素数目，...)`  


```python
a = np.arange(6)
print(a)  # [0 1 2 3 4 5]
# 修改数组的形状
a.shape=(2,3)
print(a)  # [[0 1 2] [3 4 5]] # 数组本身的形状发生了改变
print(a.shape)  # (2, 3)
```

- reshape方法

  【与shape的不同：reshape不会修改原来的数组，而是返回一个**新数组**】

  语法1：`需要reshape的数组.reshape(newshape)`

  语法2：`numpy.reshape(需要reshape的数组, newshape)`

  [newshape即为：(第一维的元素数目，第二维的元素数目，...)]


```python
a = np.arange(6)
print(a)  # [0 1 2 3 4 5]
print(a.reshape(2, 3))  # [[0 1 2] [3 4 5]]
print(a)  # [0 1 2 3 4 5] # 数组本身没有发生改变
```

注意：形状变化是基于数组元素不能改变的，变成的新形状中所包含的元素个数必须符合原来元素个数。如果数组元素发生了变化，就会报错。



### 4.2转置数组

方法1：`数组.T`

方法2：`数组.transpose()`

tips: 只要没有把转置后的新数组赋给原数组，那么原数组就不会发生变化


```python
a = np.array([[0, 1, 2], [3, 4, 5]])
print(a.T)  # [[0 3] [1 4] [2 5]]
print(a.transpose())  # [[0 3] [1 4] [2 5]]
#只要没赋值给数组本身，a的数值不会变化:
print(a)  # [[0 1 2] [3 4 5]]
a = a.T  # 或：a = a.transpose()  （都是一样的）
print(a)  # [[0 3] [1 4] [2 5]]
```



### 4.3数组连接 

将不同的数组按照一定的顺序连接起来： 

语法：`np.concatenate((数组1，数组2，...，数组n)[,axis=0])`

> asix写的是要进行数组拼接的方向:
>
> - 默认情况下，沿着第一维进行连接, axis=0，可以不写。
>
> - 如果要横沿着第二维进行连接，就可以把asix改为1

注意：

- 这些数组要用( )包括到一个元组中【即使没有写默认参数axis=0】
- 除了给定的轴外，这些数组其他轴的长度必须是一样的。


```python
x = np.array([[0,1,2],[10,11,12]])
y = np.array([[50,51,52],[60,61,62]])
print(x.shape)  # (2, 3)
print(y.shape)  # (2, 3) # 轴的长度一样-->可进行拼接

# 默认沿着第一维进行连接：(对于一维数组拼接，axis的值不影响最后的结果)
print(np.concatenate((x,y)))  # [[ 0  1  2] [10 11 12] [50 51 52] [60 61 62]]

# 沿着第二维进行连接：[把asix改为1]
print(np.concatenate((x, y), axis=1))# [[ 0  1  2 50 51 52] [10 11 12 60 61 62]]
```

------

还可以将它们连接成三维的数组，但不用concatenate，不过可以直接通过array来进行：


```python
print(np.array((x,y)))
# 结果：[[[ 0  1  2]  [10 11 12]] [[50 51 52]  [60 61 62]]]
```

----

Numpy也提供了分别对应这三种情况的函数：

* 沿着第一维进行连接：vstack
* 沿着第二维进行连接：hstack
* 连接成三维数组：dstack【注意：与直接用array连接成三维数组的方式不同】


```python
# 沿着第一维进行连接：
print(np.vstack((x,y)))# [[ 0  1  2] [10 11 12] [50 51 52] [60 61 62]]

# 沿着第二维进行连接：
print(np.hstack((x,y))) # [[ 0  1  2 50 51 52] [10 11 12 60 61 62]]

# 变成三维数组:
print(np.dstack((x,y))) # [[[ 0 50]  [ 1 51]  [ 2 52]] [[10 60]  [11 61]  [12 62]]]
```



## 5.Numpy内置函数

- 对数组的元素求绝对值：`np.abs(数组名)`
- 计算各元素的e的x次方：`np.exp(数组名)`
- 计算数组 a 中元素的中位数（中值）：`np.median(数组名)`
- 求累积和：`np.cumsum(数组名)`

numpy的内置函数 :  https://blog.csdn.net/nihaoxiaocui/article/details/51992860?locationNum=5&fps=1



## 6.数组属性方法总结 

| **调用方法**            | **作用**                                         |
| :---------------------- | :----------------------------------------------- |
| **1**                   | **基本属性**                                     |
| a.dtype                 | 数组元素类型float32,uint8,...                    |
| a.shape                 | 数组形状(m,n,o,...)                              |
| a.size                  | 数组元素数                                       |
| a.itemsize              | 每个元素占字节数                                 |
| a.nbytes                | 所有元素占的字节                                 |
| a.ndim                  | 数组维度                                         |
| -                       | -                                                |
| **2**                   | **形状相关**                                     |
| a.flat                  | 所有元素的迭代器                                 |
| a.flatten()             | 返回一个1维数组的复制                            |
| a.ravel()               | 返回一个一维数组，高效                           |
| a.resize(new_size)      | 改变形状                                         |
| a.swapaxes(axis1,axis2) | 交换两个维度的位置                               |
| a.transpose(* axex)     | 交换所有维度的位置                               |
| a.T                     | 转置，a.transpose()                              |
| a.squeeze()             | 去除所有长度为1的维度                            |
| -                       | -                                                |
| **3**                   | **填充复制**                                     |
| a.copy()                | 返回数组的一个复制                               |
| a.fill(value)           | 将数组的元组设置为特定值                         |
| -                       | -                                                |
| **4**                   | **转化**                                         |
| a.tolist()              | 将数组转化为列表                                 |
| a.tostring()            | 转换为字符串                                     |
| a.astype(dtype)         | 转换为指定类型                                   |
| a.byteswap(False)       | 转换大小字节序                                   |
| a.view(type_or_dtype)   | 生成一个使用相同内存，但使用不同的表示方法的数组 |
| -                       | -                                                |
| **5**                   | **查找排序**                                     |
| a.nonzero()             | 返回所有非零元素的索引                           |
| a.sort(axis=-1)         | 沿某个轴排序                                     |
| a.argsort(axis=-1)      | 沿某个轴，返回按排序的索引                       |
| a.searchsorted(b)       | 返回将b中元素插入a后能保持有序的索引值           |
| -                       | -                                                |
| **6**                   | **元素数学操作**                                 |
| a.clip(low,high)        | 将数值限制在一定范围内                           |
| a.round(decimals=0)     | 近似到指定精度                                   |
| a.cumsum(axis=None)     | 累加和                                           |
| a.cumprod(axis=None)    | 累乘积                                           |
| -                       | -                                                |
| **7**                   | **约简操作**                                     |
| a.sum(axis=None)        | 求和                                             |
| a.prod(axis=None)       | 求积                                             |
| a.min(axis=None)        | 最小值                                           |
| a.max(axis=None)        | 最大值                                           |
| a.argmin(axis=None)     | 最小值索引                                       |
| a.argmax(axis=None)     | 最大值索引                                       |
| a.ptp(axis=None)        | 最大值减最小值                                   |
| a.mean(axis=None)       | 平均值                                           |
| a.std(axis=None)        | 标准差                                           |
| a.var(axis=None)        | 方差                                             |
| a.any(axis=None)        | 只要有一个不为0，返回真，逻辑或                  |
| a.all(axis=None)        | 所有都不为0，返回真，逻辑与                      |



# python数据分析之Panads

## 1.1 Panads基本介绍 

> Python Data Analysis Library 或 Pandas是基于Numpy的一种工具，该工具是为了解决数据分析任务而创建的。Pandas纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。pandas提供了大量能使我们快速便捷地处理数据的函数和方法。

导入python库使用关键字**import**，后面可以自定义库的简称，但是一般都将pandas命名为pd。

使用前一定要先导入Pandas包，导入的方法有以下几种：

```python
import pandas
import pandas as pd   # 推荐写法
from pandas import *  # 不是很建议这种写法，因为使用函数时不用加前缀的话有可能会与其他函数名称起冲突，可能会导致报错
```

### Pandas 基本数据结构 

`pandas`有两种常用的基本结构：

+ `Series`（一维数组）
  + 与Numpy中的一维array类似。二者与Python基本的数据结构List也很接近。Series<u>能保存不同种数据类型</u>，字符串、boolean值、数字等都能保存在Series中。
+ `DataFrame`（二维的表格型数据结构）
  + 很多功能与R中的data.frame类似。可以将DataFrame理解为Series的容器。以下的内容主要以DataFrame为主。



## 1.2 Pandas库的series类型 

### 1.Series的初始化

一维`Series`可以用一维列表初始化：`pd.Series(列表)`  【要大写S】


```python
# eg：
s = pd.Series([1,3,5,np.nan,6,8]) # np.nan [nan(NAN,Nan)：not a number表示不是一个数字]
print(s)
"""
结果：
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64"""
# （左边的这列是下标索引）
```



### 2.自定义下标索引

默认情况下，`Series`的下标索引都是从0开始的数字，类型是统一的。也可以使用额外参数指定下标索引。

自定义下标索引语法：

1. 在series初始化时定义下标索引：`数组名=pd.Series(列表，index=要定义的下标索引组成的列表)`
2. 初始化后：`数组名.index=要定义的下标索引组成的列表`


```python
# eg：
# 方式1：
s = pd.Series([1,3,5,np.nan,6,8],index = ['a','b','c','d','e','f'])#设置索引,修改索引
# 或： s = pd.Series([1, 3, 5, np.nan, 6, 8], index=list('abcdef'))  # 设置索引,修改索引

# 方式2：
s = pd.Series([1,3,5,np.nan,6,8])
s.index = list('abcdef')

print(s)
"""
结果：
a    1.0
b    3.0
c    5.0
d    NaN
e    6.0
f    8.0
dtype: float64"""
```



### 3.查看索引

语法：`数组. index`


```python
# eg：
s = pd.Series([1,3,5,np.nan,6,8])
print(s.index) #从0到6（不含），1为步长 # RangeIndex(start=0, stop=6, step=1)
s = pd.Series([1,3,5,np.nan,6,8],index = ['a','b','c','d','x','y'])
print(s.index )# Index(['a', 'b', 'c', 'd', 'x', 'y'], dtype='object')
```



### 4.查看元素的值

- 查看所有元素的值：`数组. values`
- 根据下标查看单个元素的值：`数组[下标索引]`


```python
s.values  # [ 1.  3.  5. nan  6.  8.]
s[3]  # nan
```



### 5.切片操作

语法：`数组[start:stop:step]`【左闭右开】


```python
s[2:5] #左闭右开
"""
结果：
2    5.0
3    NaN
4    6.0
dtype: float64
"""

s[::2]
"""
结果：
0    1.0
2    5.0
4    6.0
dtype: float64
"""
```

-----

tips：可以根据自定义的索引来进行切片

注意：依据自己定义的数据类型进行切片时，就不是左闭右开了，而是**左闭右闭**

```python
# eg:
s = pd.Series([1,3,5,np.nan,6,8])
s.index = list('abcdef')
print(s['a':'c':2])
"""结果：
a    1.0
c    5.0
dtype: float64"""
```



### 6.给索引赋值

语法：`数组.index.name = '要赋得的值'`


```python
s.index.name = '索引'
print(s)
"""结果：
索引
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64"""
```



## 1.3 Pandas库的DataFrame类型

### 1.DataFrame结构的创建

- `date_range` 产生的是等差时间序列

  使用语法：`pd.date_range('日期起点',periods=要生成的日期个数)`

- 创建``DataFrame``结构（二维的表格型数据结构）：【`DataFrame`要求每一列数据的类型相同】

  - 方法1：直接传入一个二维数组：`pd.DataFrame(一个二维数组[,index=序列][，columns=序列])`

    > 可自定义索引、列标。
    >
    > 默认情况下，如果不指定``index``参数和``columns``，那么它们的值将从用0开始的整数序列替代。

    ```python
    # DataFrame是个二维结构，这里首先构造一组时间序列，作为第一维的下标（index）：
    date = pd.date_range("20180101", periods = 6)
    print(date)
    """结果:
    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',
                   '2018-01-05', '2018-01-06'],
                  dtype='datetime64[ns]', freq='D')"""
    
    # 然后创建一个DataFrame结构（二维的表格型数据结构）：
    df = pd.DataFrame(np.random.randn(6,4), index = date, columns = list("ABCD"))
    print(df)
    """
                       A         B         C         D
    2018-01-01 -0.348959 -0.311461 -0.399123 -0.325182
    2018-01-02  0.238729  1.925845 -1.222850 -0.199705
    2018-01-03  0.961151 -0.215719 -0.555677 -1.298533
    2018-01-04 -0.301778 -1.473886  1.043568 -0.811393
    2018-01-05  0.628038  1.118145 -1.571545 -0.629766
    2018-01-06  2.207462  2.356775  2.103667  0.501393
    """
    ```

  - 方法2：使用字典传入数据

    [字典的每个``key``代表一列，其``value``可以是各种能够转化为``Series``的对象]

    ```python
    df2 = pd.DataFrame({'A':1.,'B':pd.Timestamp("20181001"),'C':pd.Series(1,index = list(range(4)),dtype = float),'D':np.array([3]*4, dtype = int),'E':pd.Categorical(["test","train","test","train"]),'F':"abc"}) 
    #B:时间戳,E分类类型
    
    """结果：
         A          B    C  D      E    F
    0  1.0 2018-10-01  1.0  3   test  abc
    1  1.0 2018-10-01  1.0  3  train  abc
    2  1.0 2018-10-01  1.0  3   test  abc
    3  1.0 2018-10-01  1.0  3  train  abc
    """
    ```

    

### 2.查看数据 

- 查看头尾行的数据：（n可以不写，不写时默认为5）

  - 看前n行的数据：`DataFrame的名称.head(n)`

  - 看后n行的数据：`DataFrame的名称.tail(n)`

- 查看各个列的数据类型：`DataFrame的名称.dtypes`

- 查看下标：`DataFrame的名称.index`
- 查看列标：`DataFrame的名称.columns`
- 查看具体数据值：`DataFrame的名称.values`


```python
# 示例：
df = pd.DataFrame({'A':1.,'B':pd.Timestamp("20181001"),'C':pd.Series(1,index = list(range(4)),dtype = float),'D':np.array([3]*4, dtype = int),'E':pd.Categorical(["test","train","test","train"]),'F':"abc"}) 
print(df)
"""
     A          B    C  D      E    F
0  1.0 2018-10-01  1.0  3   test  abc
1  1.0 2018-10-01  1.0  3     12  abc
2  1.0 2018-10-01  1.0  3   test  abc
3  1.0 2018-10-01  1.0  3  train  abc"""

# 查看头3行的数据：
df.head(3)
# 查看各个列的数据类型：
df.dtypes
# 查看下标：
df.index
# 查看列标：
df.columns
# 查看具体数据值：
df.values
```

















