# Python-learning

## 1.python你好

### python解释器

一次性写多行代码：

点开IDLE-->file-->new file-->将代码写入-->ctrl+s-->命名为以 “.py” 结尾的文件中-->保存，再使用python去运行它(option-->configure IDLE)

或: 快捷键win+r-->打开命令提示符-->输入python+空格+ (例如:  d:\test.py)   [PS:输入python之后不要输入空格]



### pycharm快捷键

ctrl + alt + s : 打开软件设置

ctrl + d ：复制当前行代码

shift + alt + 上\下 ： 将当前行代码上移或下移

crtl + shift + f10 : 运行当前代码文件

shift + f6 ：重命名文件

ctrl + f : 搜索



## 2.python基础语法

### 2.1字面量

- 字面量:在代码中,被写下来的固定的值

- python中常见的6种值(数据)类型
  1. 数字类型[整型, 浮点型, 布尔, 复数(complex)]   
  
     -  布尔类型：当参加运算时(例如+-*/)，把True看作1，False看作0，直接计算   
  
     -  复数：a+bj 或 complex(a,b)   ,(实部a和虚部b都是浮点型) 
  
     - 空值：None
  
     > e记法：(科学计数法)
     >
     > eg: `1.5e4`即为：15000.0
  
  2. 字符串类型(String/str): 要用双引号(" ")引起来
  
  3. 列表(List)
  
  4. 元组(Tuple)
  
  5. 集合(Set)
  
  6. 字典(Dictionary)



### 2.2注释

- 单行注释: 以 # 开头, #右边都是注释 (tips: # 与注释内容建议以一个<u>空格</u>隔开)

- 多行注释: 以三个双引号引起来    ("""注释内容""")

  [ 多行注释一般用于解释: 整个python代码文件; 类; 方法 ]

### 2.3变量

注意点：在使用变量之前，需要对其先赋值



### 2.4print语句

- 用print语句输出多份内容:

  print(内容1,内容2,内容3,...,内容n)

  输出时这些内容时，逗号处会有一个空格

- 默认print语句输入内容会自动换行；`print()`就是输出只一个换行

  在print语句括号中加上`end=' '`或`end=" "`即可输出不换行了

  

### 2.5获取数据类型信息

- type()语句语法：`type(被查看类型的数据)`      [tips: 可查看字变量,也可查看变量]

- type()语句的使用方式:

  1. 在print语句中,直接输出类型信息

     > eg: `print(type("i am"))`

  2. 用变量存储type()的结果(返回值)——type()语句会给出结果(返回值)

     > eg:`str_type=type("great")`
     >
     > ​     `print(str_type)`

  3. 使用type()语句,查看变量中存储的数据类型信息—— (在python中, 变量无类型, 但它存储的数据有)

     > eg: `name="linda"`
     >
     > ​      `name_type=type(name)`
     >
     > ​      `print(name_type)`

----

- isinstance()语句：返回值类型为bool。判断一个对象是否是一个已知的类型，是则返回True，不是则返回False

  语法：`isinstance(对象,已知的类型)`

----

> s 为字符串
>
> s.isalnum() 所有字符都是数字或者字母，为真返回 True，否则返回 False。
>
> s.isalpha()  所有字符都是字母，为真返回 True，否则返回 False。
>
> s.isdigit()   所有字符都是数字，为真返回 True，否则返回 False。
>
> s.islower()  所有字符都是小写，为真返回 True，否则返回 False。
>
> s.isupper()  所有字符都是大写，为真返回 True，否则返回 False。
>
> s.istitle()    所有单词都是首字母大写，为真返回 True，否则返回 False。
>
> s.isspace()  所有字符都是空白字符，为真返回 True，否则返回 False。



### 2.6数据类型的转换

常见的转换语句：

int(x), float(x), str(x)：将x转换为一个整数、浮点数、字符串

> tips：
>
> - 任何数据类型都可以转换为字符串，但并不是所有字符串都可以转为数字，字符串里面只有数字的时候才可以转化为数字
>
> - 使用 int() 将正的小数转换为整数，结果是向下取整（取小的整数）；将负的小数转换为整数，结果是向上取整（取大的整数）
>
> - > 可以使得 int() 按照“四舍五入”的方式取整的方法：（＋0.5）
>   > 例如：5.4 “四舍五入”结果为：5，int(5.4+0.5) == 5
>   >            5.6 “四舍五入”结果为：6，int(5.6+0.5) == 6

-----

ord(x)：将单个字符x转换为它的整数值（得到字符的ASCII码）

list(容器)：将给定容器转换为列表

str(容器)：将给定容器转换为字符串

tuple(容器)：将给定容器转换为元组

set(容器)：将给定容器转换为集合

repr(x)：将对象 x 转换为表达式字符串【就算本来x是字符串，也要再加一对双引号】 

eval(str)：用来执行一个字符串表达式，并返回表达式的值

-----

tips：这些语句都是带有结果（返回值）的，可以用print直接输出或用变量存储它们的

### 2.7标识符

标识符：用户在编程的时候所使用的一系列名字，用于给变量、类、方法等命名

标识符命名规则：

1. 内容限定：允许出现英文字母、数字、下划线、中文

   【ps: 1.不可以以数字开头；2.不建议使用中文】

2. 大小写完全区分（对关键字同样适用，大小写与关键字不同，就不当作关键字）

3. 不可使用关键字

变量的命名规范：（软性质，最好遵守）

1. 见名知意
2. 下划线命名法（多个单词组合变量名，要使用下划线做分隔）
3. 英文字母全小写

### 2.8操作符

- 算术（数学）操作符

  +加     -减     *乘     /除(得到一个浮点数)     //取整除(得到一个整数)     %求余      **指数(乘方)

  > tips:
  >
  > - 可以使用“if a/b == int(a/b)” 这样的方式来“委曲求全 ”代替a与b求余后等于0的操作
  >
  > - > 为什么python print((2\**2)\**32)可以输出，print(2\**2\**32)不能输出？
  >   >
  >   > 由于<u>幂运算是**从右往左**运算的</u>，所以 print(2 ** 2 ** 32) 就相当于 print(2 ** 4294967296)，数字太大了，Python 一时算不出结果。而 print((2 ** 2) ** 32) 加了括号，相当于 print(4 ** 32)，Python就可以很快算出结果了

  

- （标准/复合）赋值操作符

  =     +=     -=     *=   /=   %=   **=   //=
  
  > tips:
  >
  > python允许给多个变量赋值：
  >
  > - 可以同时对多个变量赋值
  >
  >   eg:`a=b=c=1`  (从后往前赋值，3个变量都被赋值为1)
  >
  > - 也可以为多个对象指定多个变量
  >
  >   eg: `a, b, c = 1, 2, 'st'` (整型变量1、2分别赋值给a、b，字符串'st'赋值给c)
  >   
  > - 假设有 x = 1，y = 2，z = 3，快速将三个变量的值互相交换：`x, y, z = z, y, x`
  
  
  
- 比较操作符

  <  >  >=  <=   ==    !=     <>(不等于，与!=类似)    
  
  [根据表达式的真假返回bool类型的值]
  
  
  
- 逻辑操作符

  and: 两边条件都为真则结果为真，有一假则为假

  or:    两边条件都为假结果才为假，有一真则为真

  not：取它相反的bool类型的值（eg:  `not True == False`）

  [得到的结果为bool类型]

  > 区别：
  >
  > - python中的and：
  >
  >   对于  a and b： 
  >
  >   若a为false或为0，则返回a ；若a为true或不为0，则返回b的值，无论b是什么类型，若b的值为2，则返回的结果就是2 
  >
  > - C++中的&&： 
  >
  >   a && b 两者有一个为false或0时，返回0 ；否则返回1 

  

  > ﻿短路逻辑规则如下： 表达式从左至右运算
  >
  > - or逻辑
  >
  >   若 or 的左侧逻辑值为 True ，则直接输出 or 左侧表达式 。
  >
  >   若 or 的左侧逻辑值为 False ，则直接输出or右侧的表达式。
  >
  > -  and逻辑
  >
  >   若 and 的左侧逻辑值为 False ，则直接输出 and 左侧表达式
  >
  >   若 and 的左侧逻辑值为 True，则直接输出and右侧的表达式
  >
  > > 结论：从左到右，哪个可以得出结论就输出哪个。
  > >
  > > **注意：** 在Python中and的优先级是大于or的，而且and和or都是会返回值的并且**不转换为True和False**。
  > >
  > > ​            当not和and及or在一起运算时，优先级为是not>and>or
  > >
  > > ​            [eg1：5 and 2== 2;    eg2:not 1 or 0 and 1 or 3 and 4 or 5 and 6 or 7 and 8 and 9==4]        

- Python 有一个成员资格运算符：in，用于检查一个值是否在序列中，如果在序列中返回 True，否则返回 False。

  例如：

  1. \>>> name = '小甲鱼'
  2. \>>> '鱼' in name
  3. True
  4. \>>> '肥鱼' in name
  5. False





### 2.9字符串

> python没有单独的字符类型，一个字符就是长度为1的字符串

#### 2.9.1字符串的定义方式

- 三种定义方式：

1. 单引号定义法：`name='黑马' `
2. 双引号定义法：`name="黑马" `
3. 三引号定义法：`name="""黑马""" `

> tips: 三引号定义法和多行注释的写法一样，同样支持换行操作
>
> ​         使用变量接收它，它就是字符串；不使用变量接收它，它可以作为多行注释使用

- 字符串的引号嵌套
  1. 单引号定义法，可以内含双引号
  2. 双引号定义法，可以内含单引号
  3. 可以使用转义字符（\）来解除效用，变成普通字符串
  4. 在字符串的第一个引号前面加上小写字母 **r** ，后面的字符串就是一个原始字符串，转义字符不再有效，每一个字符都没有特殊的含义

#### 2.9.2字符串的拼接&重复

- 可以将两个字符串（文本）字面量/字面量和变量/变量和变量，拼接成一个字符串，通过**+号连接** (中间不加空格)

  【ps: 无法与非字符串类型进行拼接】

  （在 Python 中不能把两个完全不同的东西加在一起，比如数字和文本，所以print('I love fishc.com ' + 5) 才会报错）

  【“+”的两边的数据类型必须相同】

- 字符串可以**用" * "重复**

  ```python
  # eg:
  str = 'run'
  print(str * 2)  # 表示输出字符串2次。最后输出:runrun
  # 等同于：print(2 * str)
  ```
  
- 按字面意义级联字符串，会被自动转化为一个字符串(中间不加空格)

  ```python
  # eg:
  s="this""is""string"
  print(s) # 输出：thisisstring
  ```
  
  

#### 2.9.3字符串格式化-方式1

- 语法：`"%占位符"%变量`

  tips：多个变量占位时，变量要用括号括起来，变量之间用逗号（，）隔开，并按照占位的顺序填入

- 常用占位符：
  1. %s    将内容转化为字符串，放入占位位置
  2. %d   将内容转化为整数，放入占位位置
  3. %f    将内容转化为浮点型，放入占位位置



#### 2.9.4字符串格式化的精度控制

可以使用辅助符号”m.n“来控制数据的宽度和精度（m和.n均可省略）

- `m`: 控制宽度，要求是数字（很少使用），【当设置的宽度小于数字自身时，不生效】
- `.n`：控制小数点的精度，要求是数字，会进行小数的**四舍五入**（数据会失真）

![image-20230101161228602](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230101161228602.png)



#### 2.9.5字符串格式化-方式2（快速写法）

语法：`f"内容{变量}"`     （f 即为format，格式化的首字母）

特点：不限数据类型，不做精度控制，原样输出（适合对精度没有要求时快速使用）



#### 2.9.6对表达式进行字符串格式化

表达式：一条具有明确执行结果的代码语句

> eg: 1*3    age=11+15  type("字符")  

前面的格式化方法都是使用了变量进行格式化，在无需使用变量进行数据存储的时候，可以<u>直接格式化表达式</u>，简化代码。方式：

- `f"文字内容{表达式}"`
- `"%占位符"%(表达式1,...,表达式n)`(n>=1)

> eg:
>
> ```python
> print("1*1的结果是：%d"%(1*1)) 
> print(f"1*2的结果是：{1*2}")  
> print("字符串在python中的类型名是：%s"%type("字符串")) 
> ```



#### 2.9.7字符串格式化方式3

- 格式化字符串函数 ：`str.format()`

  基本语法是通过 `{}` 和 `:` 来代替以前的 **%** 。

- format 函数可以接受不限个参数，位置可以不按顺序。（位置参数）

  ```python
  # eg:
  # 1.不设置指定位置，按默认顺序 
  "{} {}".format("hello", "world")    # 结果：'hello world' 
  # 2.设置指定位置
  "{0} {1}".format("hello", "world")  # 结果：'hello world' 
  # 设置指定位置：
  "{1} {0} {1}".format("hello", "world")  # 结果：'world hello world'
  
  # {0},{1}为位置参数
  ```

- 也可以设置参数：（关键字参数）

  ```python
  print("名：{name}, 年龄{age}".format(name="cq", age=18))  # 名：cq, 年龄18
  # name,age为关键字参数
  ```

  

- str.format() 格式化数字
| 数字       | 格式                                                         | 输出                   | 描述                         |
| :--------- | :----------------------------------------------------------- | :--------------------- | :--------------------------- |
| 3.1415926  | {:.2f}                                                       | 3.14                   | 保留小数点后两位             |
| 3.1415926  | {:+.2f}                                                      | +3.14                  | 带符号保留小数点后两位       |
| -1         | {:-.2f}                                                      | -1.00                  | 带符号保留小数点后两位       |
| 2.71828    | {:.0f}                                                       | 3                      | 不带小数                     |
| 5          | {:0>2d}                                                      | 05                     | 数字补零 (填充左边, 宽度为2) |
| 5          | {:x<4d}                                                      | 5xxx                   | 数字补x (填充右边, 宽度为4)  |
| 10         | {:x<4d}                                                      | 10xx                   | 数字补x (填充右边, 宽度为4)  |
| 1000000    | {:,}                                                         | 1,000,000              | 以逗号分隔的数字格式         |
| 0.25       | {:.2%}                                                       | 25.00%                 | 百分比格式                   |
| 1000000000 | {:.2e}                                                       | 1.00e+09               | 指数记法                     |
| 13         | {:>10d}                                                      | 13                     | 右对齐 (默认, 宽度为10)      |
| 13         | {:<10d}                                                      | 13                     | 左对齐 (宽度为10)            |
| 13         | {:^10d}                                                      | 13                     | 中间对齐 (宽度为10)          |
| 11         | `'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)` | `1011 11 13 b 0xb 0XB` | 进制                         |

**^**, **<**, **>** 分别是居中、左对齐、右对齐，后面带宽度， **:** 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。

**+** 表示在正数前显示 **+**，负数前显示 **-**； （空格）表示在正数前加空格

b、d、o、x 分别是二进制、十进制、八进制、十六进制。



- <u>可以**使用大括号 {} 来转义大括号**</u>，如：

```python
print ("{} 对应的位置是 {{0}}".format("run"))   # 输出结果为：run对应的位置是 {0}
print("{{1}}".format("不打印", "打印"))   # 输出结果为：{1}  
# “不打印”和“打印”没有被输出是因为没有字段可以把它们打印出来
```




#### 2.9.8字符串格式化操作符辅助指令

（用字符串格式化方式1，在%后面输入）

- `m.n`：m是显示的最小总宽度，n是小数点后的位数
- `-`：用于左对齐
- `+`：在正数前面显示“+”号（负数前面不会显示）
- `#`：在八进制数前面显示零（'0'），在十六进制数前面显示'0x'或'0X'
- `0`：显示的数字前面填充'0'取代空格

![image-20230115154342728](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230115154342728.png)





#### 2.9.9字符串的比较

- 字符串比较的基准(依据)：字符对应的ASCII码值的大小
- 按位比较，从头到尾一位位进行对比。只要有一位大，整体就大，后面无需再比较



### 2.10数据输入  input()  ==【易错点】==

数据输入函数： input()

- 使用input()语句可以直接从键盘获取输入内容并回车

- 使用一个变量接收（存储）input语句获取的键盘输入数据即可
- 可以使用：input("提示信息")，来在要求使用者输入之前，显示提示信息（也可以用print语句来显示提示信息）
- 无论键盘输入什么类型的数据，获取到的数据永远都是==**字符串类型**== 【易错：要得到一个数时，一定要用强制类型转换】



### 2.11转义字符

- 制表符`\t`等同于在键盘上按下tab键，可以让多行字符串对齐

- 在字符串的前面加上小写字母 **r** ，表示后面的字符串是原始字符串，转义字符不再有效，每一个字符都没有特殊的含义

  （这里的r指raw，即raw string，会自动将让反斜杠不发生转义）

  eg: `print(r'\n')  # 输出\n`
  
  

### 2.12多行语句

- 如果一个语句较长，可以用反斜杠`\`来分成多行语句.【所以：反斜杠不能放在字符串的末尾】

  ```python
  # eg:
  total = num1 + \
          num2 + \
          num3
  ```

- 在()、[]、{}中的多行语句，不需要使用反斜杠

  ```python
  # eg:
  function_name(
     1, 2,
     3, 4)
  # 注意:使用悬挂缩进时第一行不应放置元素，并且当元素与下面内容的行相同缩进层次时，可以增加缩进来区分。
  ```


> 一行也可以书写多个语句，语句之间用分号隔开即可





## 3.判断语句

### 3.1布尔类型和比较运算符

布尔类型：进行逻辑判断，字面量只有True、False

> 布尔类型的数据，可通过<u>定义</u>或通过<u>比较运算符</u>进行内容比较得到

比较运算符：==   !=    >   <    >=   <=

### 3.2if语句的基本格式

语法：

```
if 要成立的条件：  （tips：判断条件的结果一定要是布尔类型）【ps:冒号不能漏掉】
    条件成立时要做的事情   【ps:前面要有4个空格(缩进)】
```

### 3.3if-else组合判断语句

语法：

```
if 条件：
    满足条件时要做的事情1
    满足条件时要做的事情2
    ......
else:
    不满足条件时要做的事情1
    不满足条件时要做的事情2
    ......   【ps:前面要有4个空格(缩进)】
```

### 3.4 if-elif-else的组合使用

语法：

```
if 条件1：
    条件1满足应做的事情1
    条件1满足应做的事情2
    …………
elif 条件2：
    条件2满足应做的事情1
    条件2满足应做的事情2
    …………
elif 条件n:
    条件n满足应做的事情1
    条件n满足应做的事情2
    …………
else:
    所有条件都不满足时硬座的事情1
    …………
```

### 3.5 判断语句的嵌套

嵌套的关键点：空格缩进

（通过空格缩进来决定语句之间的层次关系）

### 3.6猜数字案例

通过如下代码，可以定义一个变量num，变量内存储一个从1~10的随机数：

```python
import random  # random模块
num=random.randint(1,10)  # random模块里面的应该randint()函数，在这里它会返回一个1-10的随机整数
```



### 3.7条件表达式（三元操作符）

```python
x,y = 4, 5
if x < y:
    small = x
else:
    small = y
    
# 上面可以改为：
small = x if x < y else y
```



### 3.8断言assert

- 当assert这个关键字后面的条件为假的时候，程序会自动崩溃并抛出AssertionError的异常

  eg: 输入`assert 3>4`时

- 一般可以用assert在程序中置入检查点，这时能确保程序中的某个条件一定为真才能让程序继续正常工作。





## 4.循环语句

### 4.1while循环语句

语法：

```
while 条件：
    条件满足时应做的事情1
    条件满足时应做的事情2
    ......
```

注意：

1. while的条件需要得到布尔类型，Ture表示继续循环，False表示结束循环
2. 一定要设置使得循环终止的条件
3. 要有空格缩进，要有冒号（：）

### 4.2for循环

#### 4.2.1基础语法

语法：

```
for 临时变量 in 待处理的数据集:
    循环满足条件时执行的代码
```

for循环语句遍历字符串：是将字符串的内容依次取出，所以for循环也称为遍历循环

for循环无法定义循环条件，只能从被处理的数据集中，依次一个一个地取出内容进行处理。

将待处理的数据集一个一个地赋予给临时变量。（因为理论上被处理的数据集不可能无限大，所以python的for循环无法构建无限循环）

> 语法中的“待处理数据集”，严格来说，称之为“序列类型”。
>
> 序列类型是指其内容可以一个个依次取出的一种类型，包括：字符串、列表、元组等。
>
> for循环语句本质上是遍历序列类型

#### 4.2.2range语句

- 功能：获得一个数字序列

- 语法格式：

  1. `rang(num)`

     获取一个从0开始，到num-1结束的数字序列（不含num本身）

  2. `range(num1,num2)`

     获取一个从num1开始，到num2-1结束的数字序列（不含num2本身）

  3. `range(num1,num2,step)`

     获取一个从num1开始，到num2-1结束的数字序列（不含num2本身）

     数字之间的步长以step为准（step默认为1）

- range的用途很多，多数用在for循环场景

#### 4.2.3变量作用域

for循环中的临时变量的作用域为：循环内

（这是规范的限定，而非强制限定；如需在for循环外面访问临时变量，可以预先在循环外定义它）

### 4.3嵌套循环

for循环和while循环可以相互嵌套使用【要注意缩进】

```
for循环 或 while循环：
    满足条件时应做的事情1
    满足条件时应做的事情2
    ......
    for循环 或 while循环：
        满足条件时应做的事情1
        满足条件时应做的事情2
        ......
```

### 4.4break和continue

- continue：中断本次循环，直接进行下一次循环
- break：直接结束循环

> 在嵌套循环中，它们只作用于它们所在的循环，无法对上层的循环起作用。
>
> （若它在内层，则只影响内层循环，对外层循环不起作用）



## 5.函数

### 5.1函数介绍

函数：已组织好的、可重复使用的、用于实现特定功能的代码段

### 5.2函数的定义

- 语法：

  ```
  def 函数名(传入参数):
      函数体
      return 返回值
  ```

  > “return 返回值”、“传入参数”若不需要，可省略

- 函数的调用：

  `函数名（参数）`

  > 参数若不需要，可省略

### 5.3函数的传入参数

参数的数量不受限制，参数之间用逗号进行分隔。

传入参数的时候，要按顺序传入，和形式参数一一对应，逗号隔开。

>  注意：函数的参数是变量，而不能用元组的形式来传递
>
> ```python
> # eg:
> # 错误示范：
> # def My_Fun((x, y), (a, b)): # 这个函数的参数为0个
> #     return x * y - a * b
> 
> # 应写为：
> def fun(x, y):
>     return x[0]*x[1] - y[0]*y[1]
> 
> print(fun((3, 4), (1, 2))) # 10
> ```



### 5.4函数的返回值

#### 5.4.1函数返回值的定义

语法：`return 返回值`

【函数体遇到return关键字就结束了，写在return后的代码都不会再执行】

#### 5.4.2None类型

None作为一个特殊的字面量，表示空、无意义，其类型是<class 'NoneType>。

应用场景：

- 函数无返回值

  无返回值的函数（不使用return语句），本质上是返回了None这个字面量，等同于return None（也可以手动写return None）

    [所以事实上python的所有函数都是会返回某些东西的：有返回值就返回值，没返回值就返回None对象]

- if判断

  - 在if判断中，None等同于False
  - 一般用于在函数中返回None,配合if判断做相关处理

- 定义无内容的变量

  - 定义变量，但暂时不需要变量有具体值，可以用None来代替

### 5.5函数的说明文档

- 作用：对函数进行说明解释，帮助更好地理解函数的功能

- 定义语法：

  ```python
  def 函数名(形参1，形参2，...,形参n):
      """
      函数说明
      :param 形参1: 对参数1的说明
      :param 形参2: 对参数2的说明
       ...
      :param 形参n: 对参数n的说明
      :return: 对返回值的说明
      """
      函数体
      return 返回值
  ```

  > :param 用于解释参数
  >
  > :return 用于解释返回值

- 查看调用函数的说明文档方法：

  1. 用pycharm编写代码时，可以通过鼠标悬停查看

  2. 通过`print(函数名.__doc__)`
  3. 通过`help(函数名)`

  

### 5.6变量在函数中的作用域

> 局部变量：只能在函数内部使用，在函数外部无法使用
>
> 全局变量：在函数内部和外部均可使用

- 全局变量在整个代码当中都是可以被访问的，可以在函数内部访问它（读取它的值），但是不能在函数内部修改它。
  如果在函数内试图修改全局变量的值，那么python会自动新建一个新的局部变量，名字与全局变量一模一样（虽然它们的名字一样，但是存储的空间不同，所以它们是互不影响的）

- 使用**global**关键字，可以在函数内部声明变量为全局变量: 

  语法： `global 变量名`

  ```python
  # eg:
  def my_func():
      global num
      num = 10
  
  
  num = 5
  my_func()
  print(num) # 10
  ```



### 5.7内嵌函数

内部函数整个作用域都在外部函数之内。

【如果函数1里面还有定义函数2，那么函数2只能在函数1里面被调用。在函数1外面不能被调用】

【注意：如果函数2只是在函数1里面定义，而没有在函数1里面调用的话，即使调用了函数1，也不会执行函数2里面的语句】

```python
# 如果函数2只是在函数1里面定义，而没有在函数1里面调用的话，即使调用了函数1，也不会执行函数2里面的语句
# eg:
def func1():
    print("正在调用函数1")
    def func2():
        print("正在调用函数2")


func1() # 这样的话就只会调用func1，而不会调用func2。结果只有：正在调用函数1
```

```python
# 如果只在函数1里面调用了函数2，而函数1没有被调用，那它们两个函数都不会执行
# eg：
def func1():
    print("正在调用函数1")
    def func2():
        print("正在调用函数2")
    func2()
# 没有结果，不报错
```

```python
# 如果函数1里面还有定义函数2，那么函数2只能在函数1里面被调用。在函数1外面不能被调用
# eg:
def func1():
    print("正在调用函数1")
    def func2():
        print("正在调用函数2")


func1()  # 这样的话就只会调用func1，而不会调用func2。
func2()
# 虽然有结果：“正在调用函数1”。但是也会报错【因为不能在func1之外调用func2】
```



### 5.8闭包（closure）

- 在python中，闭包从表现形式上定义为：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就会被认为是闭包。（引用外部函数的变量的内部函数是一个闭包）

  ```python
  # eg:
  def fun1(x):
      
      def fun2(y):
          return x * y
      
      return fun2
  
  # 对于fun1这个函数来说，fun2是它的内部函数。在fun2里面，对在外部作用域（也就是fun1）的变量x进行了引用。那么就fun2就是一个闭包。
  
  print(fun1(3)(5))  # 15
  # 其实这个语句相当于：a = fun1(3); b = a(5) ;print(b)
  # 因为fun1返回的就是fun2，所以其实a就是一个函数（相当于fun2）  【type(a)==<class 'function'>】
  # 相当于把3传给fun1，即x=3；把5传给fun2，即y=5.所以得到的结果b是调用fun2，得到的是fun2的返回值x*y，即3*5——15
  ```

- 注意：

  - 因为闭包这个概念是由内部函数演变而来，所以也不能在外部函数外面对内部函数进行调用。

  - 在闭包中，“外部函数的局部变量与内部函数的局部变量的关系”  事实上就相当于  “全局变量与局部变量的关系”。在内部函数中，只能对外部函数的局部变量进行访问，但不能对它进行修改。如果在内部函数内试图修改外部函数的局部变量的值，那么python会在内部函数中自动新建一个新的局部变量，名字与全局变量一模一样。

    ```python
    # eg:【易错】
    def fun1():
        x = 5
        
        def fun2():
            x *= x  
            return x
        
        return fun2
    
    print(fun1())# 会报错
    # 因为x*=x这里相当于想要试图把x的值修改，那么python会自动屏蔽掉x=5，而自动新建一个同名变量x。
    # 而又因为不能对一个没有定义过的数据x进行平方操作。
    ```

    - 解决方案1：通过容器类型进行存放。

      （因为容器类型不是存放在栈里面，所以内部函数想要修改外部函数的变量时，外部函数的这个变量不会被屏蔽掉，所以这样子也就不会导致问题的出现）

      ```python
      # 即：例如可把变量改成列表：
      def fun1():
          x = [5]
      
          def fun2():
              x[0] *= x[0]
              return x[0]
      
          return fun2()
      
      
      print(fun1())  # 25
      ```

    - 解决方案2：利用nonlocal关键字（使用方法跟global类似）

      【nonlocal关键字：在函数里面强制声明为它不是局部变量。语法： `nonlocal 变量名`】

      ```python
      # 即：
      def fun1():
          x = 5
      
          def fun2():
              nonlocal x
              x *= x
              return x
      
          return fun2()
      
      
      print(fun1())  # 25
      ```

      > 主要区别有：
      >
      > 1. 两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。
      >
      > 2. 两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误。

  

## 6.数据容器

### 6.1数据容器简介

- python中的数据容器：

  一个容器可以容纳多份数据，容纳的每一份数据称为一个元素。

  每一个元素，可以是任意类型的数据，如字符串、数字、布尔等。

- 数据容器根据特点的不同，如：是否支持重复元素、是否可以修改、是否有序等，分成五类：

  列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）

  [它们各有各的特点，但都可以满足多个元素的特性]

### 6.2列表list
#### 6.2.1列表的定义

基本语法：

```python
# 定义列表字面量：
[元素1,元素2,......]

# 定义列表变量：
变量名称=[元素1,元素2,......]

# 定义空列表（2种方式）：
变量名称=[]
变量名称=list()
```

- 以[ ]作为标识，每一个元素之间用逗号 "," 隔开

- 列表可以一次存储多个数据，且可以为不同的数据类型（也可以是列表），支持嵌套

#### 6.2.2列表的下标（索引）

可以使用列表的下标/索引，即可从列表中取出对应位置的数据

语法：`列表 [下标]`

- 正向索引，即从左往右：列表中第一个元素为0，从0开始，依次递增

- 反向索引，即从右往左：列表中最后一个元素为-1，从-1开始，依次递减（-1、-2、...）
- 嵌套列表的下标索引：如果列表是嵌套的列表，同样支持下标索引

PS：要注意下标索引的取值范围，超出范围后不仅无法取出元素，而且会报错



#### 6.2.3列表的常用操作

- 列表的查询功能

  - 查找指定元素在列表中的下标

    语法：`列表. index(元素)`  
    
    > - 会返回元素在列表中的位置
    >
    > - 如果找不到，会报错ValueError
    > - 其实还有两个参数，即完整语法：`列表.index(元素，范围的起始下标，范围的结束下标)`   (结束下标不包括在内)
    > - 如果有重复元素，则只是返回第一个的位置

  - 统计某元素在列表中的数量

    语法：`列表.count(元素)`

  - 统计列表内有多少元素

    语法：`len(列表)`

    [ 返回一个int数字，表示列表内的元素数量]
    
  - 返回列表元素最大值

    语法：`max(列表)`

  - 返回列表元素最小值

    语法：`min(列表)`

    

- 列表的修改功能

  - 修改特定位置（索引）的元素值

    功能：直接对指定下标的值进行修改/重新赋值

    语法：`列表[下标]=值`

  - 插入(加入)元素

    功能：在指定的下标位置，插入指定的元素（插入位置及其后面的元素都往后挪一位）

    语法：`列表.insert(下标，元素)`

  - 追加元素

    - 追加<u>单个</u>元素

      功能：将<u>一个</u>指定元素追加到列表的尾部 (这个元素可以是列表等数据容器)

      语法：`列表.append(元素)`

    - 追加一批元素（这一批元素是在其他数据容器中的）

      功能：将其他数据容器的内容取出，依次追加到列表尾部

      语法：`列表.extend(其他数据容器)`  （其他数据容器不一定要是列表）

  - 删除元素：

    - 删除指定下标的元素:

      - 语法1：`del列表[下标]`    【del后面如果只加上列表，那就会把整个列表删除】

      - 语法2：`列表.pop(下标)`  

        > -  不仅能把元素从列表中删除，还能将被删除的元素作为返回值得到【返回的被删除掉的元素，可以用变量接收它】
        > - 当没有传入下标时，即：`列表.pop()`，此时会把列表的最后一个元素从列表中删除并返回
    
    - 删除某元素在列表中的<u>第一个</u>匹配项
    
      语法：`列表.remove(元素)`
    
      （只能删掉一个，如果想要删掉多个同样的元素，可以多调用几次remove方法）
    
    - 清空列表内容（整个列表）
    
      语法：`列表.clear()`
    
      【注意: 清空完后列表仍然还在哦，只是结果变成一个空列表：[] 】
    
  - 拷贝列表
  
       (把列表1的内容拷贝给列表2)
  
    - 方法一：(切片操作)  `列表2 = 列表1[:]`
  - 方法二：`列表2 = 列表1.copy()`
  
  
  
  - 反转列表
  
    语法：`列表.reverse()`【使得列表中本身的元素的顺序完全反转过来，没有返回新列表，是使得列表本身发生改变】
  
    ```python
    # eg:
    list1 = [123, 234, 345, 456]
    list1.reverse()
    print(list1)  # [456, 345, 234, 123]
    ```
  
  - 将列表排序【使得<u>列表中本身的元素的顺序改变</u>，没有返回值或新列表（返回值为None），是使得<u>列表本身发生改变</u>】
  
    - 从小到大排序
  
      语法：`列表.sort()`     [默认参数reverse=False]
  
    - 从大到小排序
  
      语法：`列表.sort(reverse=Ture)`        
      
      > 其实`列表.sort(reverse=Ture)` 等同于：
      >
      > ```python
      > 列表.sort()
      > 列表.reverse()
      > ```
  
    ```python
    # eg:
    list1 = [1, 5, 3, 9, 0, 4]
    list1.sort()
    print(list1)  # [0, 1, 3, 4, 5, 9]
    
    l = list1.sort(reverse=True)
    print(list1)  # [9, 5, 4, 3, 1, 0]
    print(l)  # None
    ```
  
    

#### 6.2.4列表的特点

- 可以容纳多个元素（上限为2**63-1）
- 可以容纳不同类型的元素（混装）
- 数据是有序存储的（有下标序号）
- 允许重复数据存在
- 可以修改（增加、删除等）



#### 6.2.5列表的循环遍历

1. 用while循环

   ```python
   index=0
   while index<len(列表):
       元素=列表[index]
       对元素进行处理
       index+=1
   ```

2. 用for循环（不需要控制循环条件）

   ```python
   for 临时变量 in 数据容器:
       对临时变量（列表中的元素）进行处理
   ```

![image-20230105172044255](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230105172044255.png)

- for循环更简单，while更灵活



#### 6.2.6列表的常用操作符

- 比较操作符

  比较的方法与字符串的比较类似：按位比较，从头到尾一个个元素进行对比。只要有一位大，整体就大，后面无需再比较

- 逻辑操作符（and, or, not）

- 连接操作符（+） 【不会改变原列表】   （不要随意用，最好还是老实用append，extend等）

  注意：“+”无法实现添加新元素，只能是两个列表之间进行“+”【“+”的两边的数据类型必须相同】

- 重复操作符(*)    【不会改变原列表】

- 赋值操作符  【会改变原列表】

- 成员关系操作符：in，not in

- ```python
  # eg:
  list1 = [123, 456]
  list2 = [234, 123]
  list3 = [123, 456]
  # 比较操作符:
  print(list1 > list2)  # False
  
  # 逻辑操作符：
  print((list1 < list2) and (list1 == list3))  # True
  
  # 连接操作符：
  list4 = list1 + list2
  print(list4)   # list4 == [123, 456, 234, 123]
  # 错误示范：
  #list4 = list1 + 'no1'  # “+”无法实现添加新元素，只能是两个列表之间进行“+”
  
  # 重复操作符：
  list5 = list1 * 3
  print(list5)  # list5 = [123, 456, 123, 456, 123, 456]
  
  # 赋值操作符：
  list3 *= 3
  print(list3)  # list3 = [123, 456, 123, 456, 123, 456]
  
  # 成员关系操作符：
  print(123 in list1)   # True
  print(123 not in list1)  # False
  
  list6 = [123, [234, 345], 456]
  print(234 in list6)  # False
  print(234 in list6[1])  # True
  print(list6[1][0])  # 234
  ```



#### 6.2.7列表推导式

是一个非常有用和灵活的工具，可以用来动态的创建列表

语法：`[表达式 for 变量 in 列表]`   或  `[表达式 for 变量 in 列表 if 条件] `   

`[有关A的表达式 for A in B]`

```python
# eg:
print([i*i for i in range(10)])  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
print([x**2 for x in range(10)]) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```



### 6.3元组tuple

元组一旦定义完成，就不可修改。所以，当我们需要在程序内封装数据，又不希望封装的数据被纂改时，可以用元组。

#### 6.3.1元组的定义

使用小括号（），且使用逗号“，”隔开各个数据。数据可以是不同的数据类型, 元组也支持嵌套

```python
# 定义元组字变量
（元素1，元素2，....）

# 定义元组变量：
变量名称=（元素1,元素2,......）

# 定义空元组（2种方式）：
变量名称=（）
变量名称=tuple()
```

注意：当元组<u>只有一个数据时，这个数据后面也要**必须要加逗号**</u>，否则就不是元组类型，会认为是一个普通的数字类型或字符串类型。    【逗号是元组的标志】

```python
# eg:
temp = (1)   # 这个小括号会别认为是多余的
print(type(temp))  # <class 'int'>
temp = (1,)
print(type(temp))  # <class 'tuple'>

print(6 * (6)) # 36
print(6 * (6,)) # (6, 6, 6, 6, 6, 6)  # 元组的重复操作
```

> 所有的多对象的、**逗号**分隔的、没有明确用符号定义的这些集合默认的类型都是元组
>
> ```python
> x, y, z = 1, 2, 3
> print(type(x))  # <class 'int'>
> h = x, y, z
> print(type(h))  # <class 'tuple'>
> ```

#### 6.3.2元组的下标索引

（与列表相同）

#### 6.3.3元组的相关操作（方法）

- `元组.index(元素)`

  查找某个数据，如果数据存在就返回它对应的下标，否则报错

- `元组.count(元素)`

  统计某个数据在当前元组出现的次数

- `len(元组)`

  统计元组内的元素个数

> 注意：
>
> - 不可以修改元组的内容，否则会报错
>
> - 可以修改元组内list的内容（修改元素、增加、删除、反转等等）.
>
>   eg:
>
>   ```python
>   t=(1,2,['i','am'])
>   t[0]=3  # 错误
>   t[2][1]='best'  # 可以
>   print(t) #输出(1,2,['best','am'])
>   ```
>

- 删除元组：`del 元组`



#### 6.3.4元组的特点

- 可以容纳多个数据
- 可以容纳不同类型的数据（混装）
- 数据是有序存储的（下标索引）
- 支持重复元素
- **不可修改**（增加或修改等）
- 支持for、while循环

#### 6.3.5元组的循环遍历

1. 用while循环

   ```python
   index=0
   while index<len(元组):
       元素=元组[index]
       对元素进行处理
       index+=1  
   ```

2. 用for循环

   ```python
   for 临时变量 in 元组:
       对临时变量（元组中的元素）进行处理
   ```



#### 6.3.6元组的常用操作符

[与列表类似]

- 拼接操作符（+）  【一定要注意“+”的两边的数据类型必须一致，尤其是元组只有一个元素的情况】

  ```python
  # eg:
  temp = ('apple', 'peach', 'banana', 'grape')
  temp = temp[:2] + ('orange',)    
  # 注意：temp = temp[:2] + 'orange'  或 temp = temp[:2] + ('orange') 都是错误的 
  
  print(temp) # ('apple', 'peach', 'orange')
  ```

- 重复操作符（*）

  ```python
  # eg:
  print(6 * (6)) # 36
  print(6 * (6,)) # (6, 6, 6, 6, 6, 6)  # 重复操作 # 注意：要有逗号才是元组
  ```

- 成员关系操作符（in，not in）

- 比较操作符（>  <  >=  <=）

- 逻辑操作符（and ,or..）

- 赋值操作符

- tips：若想要更新一个元组，可以：【注意：在这里原来的元组没有发生改变，只是原来元组的被覆盖了】

  元组中的元素值是不允许修改的，但可以对元组进行连接组合
  
  ```python
  # eg:
  temp = ('apple', 'peach', 'banana', 'grape')
  temp = temp[:2] + ('orange',) + temp[2:]    
  print(temp)  # ('apple', 'peach', 'orange', 'banana', 'grape')
  ```





### 6.4字符串str(数据容器视角下的)

#### 6.4.1字符串的定义和下标索引

- 字符串是字符的容器，一个字符串可以存放任意数量的字符。

- 字符串也可以通过下标索引访问：

  从左往右，下标从0开始；从右往左，下标从-1开始

  语法：`字符串[下标]`

- 字符串是一个**无法修改**的数据容器

  （修改或移除指定下标的字符、追加字符等操作都无法完成。如果必须要做，只能得到一个新的字符串）

#### 6.4.2字符串的常用操作

- 查找特定字符串的下标索引值（以字符串1的第一个字符的位置为准)

  语法：`字符串.index(字符串1)`

- 字符串的替换

  语法：`字符串.replace(字符串1,字符串2)`

  功能：将字符串内的全部的字符串1替换为字符串2

  注意：不是修改字符串本身，而是得到了一个新的字符串

  （本质上是会得到一个返回值，返回值里面会得到一个新的字符串；但老的字符串是只读的，不可修改的，不会改变）

- 字符串的分割

  语法：`字符串.split(分隔符字符串)`

  功能：按照指定的分隔符字符串，将字符串划分为多个字符串，并存入列表对象中（如果不指定，则默认以空格来分隔字符串）

  注意：字符串本身不变，而是得到了一个新的列表对象

  （本质上是会得到一个返回值，返回值的类型是列表）

- 字符串的规整操作

  - 去前后（首尾）空格以及换行符：（不传参数）
  
    语法：`字符串.strip()`
  
  - 去前后（首尾）指定字符串：（传参数）
  
    语法：`字符串.strip(字符串)`
  
    注意：传入的字符串其实会被认为是几个小“子串”，会按照单个字符去移除
  
    > eg:
    >
    > ```python
    > s = "123312i am happy13"
    > t = s.strip("123")
    > print(t)  # 输出“i am happy”
    > ```
    >
    > 传入的是“123”，但其实会把它划分为“1”、“2”和“3”三个小“字串”，只要有这几个小“子串”都会移除，是按照单个字符去除的，也就是去除字符串“1”、“2”和“3”
  
- 统计字符串中某字符串（字符串1）的出现次数

  语法：`字符串.count(字符串1)`

- 统计字符串的长度

  语法：`len(字符串)`
  
  

#### 6.4.3字符串的遍历

（与列表、元组一样）

#### 6.4.4字符串的特点

- 只可以存储字符串
- 长度任意（取决于电脑内存大小）
- 支持下标索引
- 允许重复字符串存在
- **不可以修改**
- 支持for、while循环

#### 6.4.5字符串的常用操作符

（与元组类似）

tips：若想要更新一个字符串，可以：【注意：在这里原来的字符串没有发生改变，只是原来字符串的被覆盖了】

【字符串中的元素值是不允许修改的，但可以对字符串进行连接组合】

```python
# eg:
temp = 'i love you'
temp = temp[:6] + '插入' + temp[6:]    
print(temp)  # i love插入 you
```



#### 6.2.6关于字符串的一些内置方法

【注意：使用这些方法时，原来的字符串没有发生改变，只是返回了一个新的字符串（可用变量接收）】

- `字符串.capitalize()`：把字符串的第一个字符改为大写

- `字符串.casefold()`：把整个字符串的所有字符改为小写（如果原来也都是小写）

- `字符串.center(width)`：将字符串居中，并使用空格将整个字符串填充至长度为width的新字符串

- `字符串.count(sub,[start[,end]])`：返回sub在字符串里面出现的次数。start和end参数表示范围（可选）

- `字符串.encode(encoding='UTF-8',errors='strict')`：以encoding指定的编码格式对字符串进行编码。（encoding -- 要使用的编码，如: UTF-8；errors -- 设置不同错误的处理方案。）

- `字符串.endswith(sub,[start[,end]])`：检查字符串是否以sub子字符串结束，如果是则返回True，否则返回False。start和end参数表示范围（可选）
- `字符串.expandtab([tabzise=8])`：将字符串中的tab（\t）转化为空格，如果不指定参数，则默认的空格数是tabzise=8
- `字符串.find(sub,[start[,end]])`：
- ………………………………



### 6.5序列

#### 6.5.1序列的概念

序列：内容连续、有序，可使用下标索引的一类数据容器

列表、元组、字符串均可以视为序列

共同点：

- 可使用下标索引
- 默认索引值都是从0开始
- 可以通过切片操作得到一个范围内的子序列
- 共同操作符：拼接操作符、重复操作符、成员关系操作符等



#### 6.5.2序列的切片操作

切片：从一个序列中，取出一个子序列

语法：`序列[起始下标：结束下标：步长]`

> 表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列。【返回一个子**序列**（列表、元组、字符串）】
>
> - 起始下标表示从何处开始，可以留空（留空视为从头开始）
>
> - 结束下标表示在何处结束，可以留空（留空视为截取到结尾）
>
>   【注意：结束下标的位置是**不包括在内**的—可理解为“左闭右开区间”】
>
> - 步长表示依次取元素的间隔：
>
>   - 步长默认是1，当步长是1时可以省略不写。即：`序列[起始下标：结束下标]`
>
>   - 步长1表示一个个取元素
>
>   - 步长2表示每次跳过一个元素取
>
>   - 步长n表示每次跳过n-1个元素取
>
>   - 步长为负数表示倒序进行
>
>     【注意：起始下标和结束下标也要反向标记（不一定需要改为负的下标，把正的下标反过来也行）】
>
>   - 可用`序列[::-1]`来得到序列**反转**后得到的序列

注意：切片操作**不会影响序列本身**，而是会得到一个新的序列（因为元组和字符串都是不可修改的）



#### 6.5.3关于切片“拷贝”概念的补充

例如：可以利用分片完成列表的拷贝 list2 = list1[:]，但事实上可以直接写成 list2 = list1 吗？【易出错】

事实上：

- `list2 = list1[:]`才是真正的拷贝，把list1的内容拷到list2里面，而且后面再对list1进行改动时，list2不会因为list1的改变而跟着改变。（相当于文件的复制粘贴）

- 而`list2 = list1`在python中相当于是指针，list2与list1所指地方都是相同的，即当list1发生改变时，list2也会跟着发生一样的变动。或者说，这是“深层拷贝”。（相当于文件的快捷方式）

```python
# eg:
list1 = [1, 5, 3, 9, 0, 4]
list2 = list1[:]
list3 = list1

list1.sort()
print(list1) # [0, 1, 3, 4, 5, 9]
print(list2) # [1, 5, 3, 9, 0, 4]
print(list3) # [0, 1, 3, 4, 5, 9]
```

图解：![image-20230114121139982](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230114121139982.png)

> tips:  区分：
>
> - 上面的`list1.sort()`是使得list1本身发生了改变，所以跟list1指向相同的list3也会发生一样的改变。
>
> - 但是：
>
>   ```python
>   # eg:
>   old = [1, 2, 3, 4, 5]
>   new = old
>   old = [6]
>   print(new) # [1, 2, 3, 4, 5]
>   ```
>
>   old只是被[6]覆盖掉了，但new还是对应着old原来的n'g



#### 6.5.4关于序列的常见方法

- `list([iterable])`：把一个可迭代对象转换成列表    

  `tuple([iterable])`：把一个可迭代对象转换成元组    

  `str(obj)`：把obj(对象)转换为字符串

  > 迭代是重复反馈过程的活动，其目的通常是为了接近并到达所需的目标或结果。每一次对过程的重复被称为一次“迭代”，而每一次迭代得到的结果会被用来作为下一次迭代的初始值。

- `len(序列)`:返回序列的长度

- `max(x)`：返回序列或参数集合中的最大值

  `min(x)`：返回序列或参数集合中的最小值

  > 注意：使用max和min方法都必须要保证容器内的**数据类型是统一**的，全部都是字符/整数/浮点数/元组/……

- `sum(iterable[,start=0])`：返回序列iterable（和可选参数start）的总和

  > 注意：不是数字类型的不能进行sum操作（eg：字符串）

- `sorted(容器，[reverse=Ture])`

  作用：将给定容器进行排序

  > - 该函数有2个参数：第一个参数是被排序的容器；第二个参数是一个有默认值的参数reverse（reverse默认等于false）
  > - 排序后的结果会通通变成**列表**【其实sorted函数就是会对内容进行排序，然后放到列表之中 (字典排序后就会丢失掉value)】
  > - reverse -- 排序规则：
  >   - 正向（升序）排序时，直接：`sorted(容器)`  【reverse = False 升序（默认）】
  >   - 需要反向（降序）排序时：`sorted(容器，[reverse=Ture])`

- `reverse(序列)`：返回一个反转的迭代器对象

  `list(reversed(序列))`：得到一个反转的列表    【与：`列表.reverse()`的作用类似】

  ```python
  # eg：
  # 字符串
  seqString = 'Runoob'
  print(list(reversed(seqString)))
   
  # 元组
  seqTuple = ('R', 'u', 'n', 'o', 'o', 'b')
  print(list(reversed(seqTuple)))
   
  # range
  seqRange = range(5, 9)
  print(list(reversed(seqRange)))
   
  # 列表
  seqList = [1, 2, 4, 3, 5]
  print(list(reversed(seqList)))
  ```

- `enumerate(sequence, [start=0])`：将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标。sequence -- 一个序列、迭代器或其他支持迭代对象。start -- 下标起始位置。返回 enumerate(枚举) 对象。

  `list(enumerate(sequence, [start=0]))`：得到一个列表

  ```python
  # eg:
  seasons = ['Spring', 'Summer', 'Fall', 'Winter']
  list(enumerate(seasons))
  [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
  list(enumerate(seasons, start=1))    # 小标从 1 开始
  [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]
  ```

- `zip([iterable, ...])`：用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。（iterabl -- 一个或多个迭代器）

  `list(zip([iterable, ...]))`：得到一个列表

  ```python
  a = [1, 2, 3, 4, 5, 6, 7, 8]
  b = [4, 5, 6, 7, 8]
  print(list(zip(a, b)))  # [(1, 4), (2, 5), (3, 6), (4, 7), (5, 8)]
  ```





### 6.6集合set

#### 6.6.1集合的定义

基本语法：

```python
# 定义集合字变量
{元素1，元素2，....}

# 定义集合变量：
变量名称={元素1,元素2,......}

# 定义空集合：
变量名称=set()   # 注意：创建新集合不能用{},必须用set()。{}是用来创建一个新字典的
```

使用{}定义，元素之间用“，”隔开

#### 6.6.2集合的常见操作

- 集合是内容是无序的，不支持下标索引访问。  ——所以，集合不是序列

- 集合是允许修改的：

  - 增加新元素

    语法：`集合.add(元素)`

    功能：将指定元素添加到集合内

    结果：集合本身被修改，添加了新元素

  - 移除元素

    语法：`集合.remove(元素)`

    功能：将指定元素从集合内移除

    结果：集合本身被修改，移除了元素

  - 从集合中<u>随机</u>取出元素

    语法：`集合.pop()`

    功能：从集合中随机取出一个元素

    结果：返回一个被随机取出的元素（可用变量接收）。同时，集合本身被修改，有一个元素被移除

  - 清空集合

    语法：`集合.clear()`

    结果：集合本身被清空，变成空集合：`set()`

  - 消除两个集合的差集

    语法：`集合1.difference_update(集合2)`

    功能：对比集合1和集合2，在集合1内，删除与集合2相同的元素

    结果：<u>集合1被修改，集合2不变</u>

- 取两个集合的差集

  语法：`集合1.difference(集合2)`

  功能：取出集合1和集合2的差集（集合1有而集合2没有的）

  结果：返回一个**新集合**（可用变量接收），集合1和集合2不变

- 两个集合合并

  语法：`集合1.union(集合2)`
  
  功能：将集合1和集合2组合成一个新集合
  
  结果：返回一个**新集合**（可用变量接收），集合1和集合2不变（会自动去重）
  
- 统计集合元素数量
  
  语法：`len(集合)`
  
  结果：返回一个整型数字（可用变量接收）【会自动去重】

#### 6.6.3集合的遍历

PS:集合不支持下标索引，所以**不能用while循环**。

但可以用for循环：

```python
for 临时变量 in 集合:
    对临时变量（集合中的元素）进行处理
```

#### 6.6.4集合的特点

- <u>不支持元素的重复，不允许重复数据存在（自带去重处理）</u>
- <u>数据是无序存储的（不支持下标索引）</u>
- 可以容纳多个数据
- 可以容纳不同类型的数据（混装）
- 可以修改（增加或删除元素）
- 支持for循环，不支持while循环

#### 6.6.5集合的运算

set可以进行集合运算：

```python
# eg:
a = set('abxdbefjv')
b = set('ahsbxurme')

print(a - b)  # a和b的差集(a有而b没有的)
print(b - a)  # b和a的差集(b有而a没有的)

print(a + b)  # a和b的并集
print(a | b)  # a和b的并集

print(a & b)  # a和b的交集
print(a ^ b)  # a和b中不同时存在的元素
# 以集合形式，去重并输出
```



#### 6.6.6不可变集合

**frozenset()** 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。

语法：`frozenset(interable)`   [参数interable为可迭代对象，可以为列表、元组、字符串、字典、集合等]

```python
# eg:
num = frozenset([1, 2, 3, 5, 4, 5, 5])  
print(num)  # frozenset({1, 2, 3, 4, 5})
# 会报错：
# num.add(0) 
```



### 6.7字典dict

#### 6.7.1字典的定义

基本语法：

```python
# 定义字典字变量
{Key1:Value1,Key2:Value2,...}

# 定义字典变量：
变量名称={Key1:Value1,Key2:Value2,...}

# 定义空字典（2种方式）：
变量名称={}
变量名称=dict()
```

使用{}，元素之间用","隔开。不过存储的元素是一个个的键值对

------

创建字典的其他方法：

- 用映射关系创建一个字典

  [dict里面传的是一个<u>映射关系</u>的参数（可用元组或列表）]【dict里面只能有一个参数】

  ```python
  # eg:
  # 传元组：
  dict1 = dict((('a',1),('b',2),('c',3),('d',4)))#别看括号这么多，它们可都不是多余的，只是因为dict里面只能有1个参数
  print(dict1)   # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
  # 传列表
  dict2 = dict([('a', 1), ('b', 2), ('c', 3), ('d', 4)])
  print(dict2)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}
  ```

- 用关键字参数创建一个字典 【key不能加引号】

  （给key加引号会报错，因为它不能是一个表达式。直接给它一个数据，它会自动以字符串的形式包裹起来。如果加了引号，等号两边的数据类型相同，会被认为是一个表达式）

  ```python
  # eg:
  dict3 = dict(linda='1', tom='2', wendy='3')
  print(dict3) # {'linda': 1, 'tom': 2, 'wendy': 3}
  dict4 = dict(linda='1', tom='2', wendy='3')
  print(dict4) # {'linda': '1', 'tom': '2', 'wendy': '3'}
  
  # 会报错：
  # dict5 = dict('linda'='1', 'tom'='2', 'wendy'='3')
  # dict6 = dict('linda'=1, 'tom'=2, 'wendy'=3)           # 表达式不能包含赋值
  ```

  

#### 6.7.2字典的注意事项

- Key不允许重复

  如果有重复的key，那么就只会保留后面的那个键值对（Key:Value）（不可以重复，所以新的会把老的给覆盖掉）【也不支持一键(key)多值(value)】

  > eg:
  >
  > ```python
  > mydict={"apple":98,"apple":99,"peach":100,}
  > print(mydict)  # 输出{'apple': 99, 'peach': 100}
  > ```

- 字典不可用下标索引，但是字典可以通过Key值来取得对应的Value

  语法：`字典[key]`

- 字典的嵌套

  - 字典中的Key可以为**字典除外**的任意数据类型；
- Value可以为任意数据类型

#### 6.7.3字典的相关操作

- 新增元素

  语法：`字典[Key]=Value`

  结果：字典被修改，创建新的key并赋予它对应的value值，新增了元素（当这个Key还没存在时）

- 更新元素

  语法：`字典[Key]=Value`

  结果：字典被修改，修改key对应的value值，元素被更新（当这个Key已经存在时）

  注意：字典的Key不可以重复，所以对已存在的Key进行上述操作就是更新Value值

- 利用一个字典或映射关系（）集合取更新另外一个字典

  语法：`字典.update(元素或字典)`

  ```python
  # eg:
  a = {1: 'one', 2: 'two', 3: 'three'}
  b = {4:'four'}
  a.update(b)
  print(a)  # {1: 'one', 2: 'two', 3: 'three', 4: 'four'}
  c = {5: 'five', 6: 'six'}
  a.update(c)
  print(a)  # {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six'}
  ```

  

- 删除元素

  - 方法1：`字典.pop(Key)`

    结果：返回指定Key的<u>Value</u>（可以用变量来接收），同时字典被修改，指定的key和它对应的value整个键值对的数据被删除

  - 方法2：`字典.popitem()`

    结果：<u>随机</u>删除字典里面的一个键值对，并把被删除的键和值用元组的形式[即：（键，值）]打包返回

  ```python
  a = {1: 'one', 2: 'two', 3: 'three'}
  b = a.pop(2)
  print(a)  # {1: 'one', 3: 'three'}
  print(b)  # two
  
  c = a.popitem()
  print(a)  # {1: 'one'}
  print(c)  # (3, 'three')
  ```

  

- 清空元素

  语法：`字典.clear()`
  
  结果：字典**本身**被清空，变成空字典：{}
  
  > 是否可以直接让“ 字典 = {} ”来表示让字典清空？
  >
  > 严格意义上不可以，因为：
  >
  > ```python
  > a = {1: 'one'}
  > b = a  # b和a指向同一个地方
  > a = {}
  > print(a)  # {}
  > print(b)  # {1: 'one'}
  > 
  > c = {2: 'two'}
  > d = c  # c和d指向同一个地方
  > c.clear()
  > print(c)  # {}
  > print(d)  # {}
  > ```
  
- 浅拷贝（对对象表层的一个拷贝）【浅拷贝不是直接赋值】

  > 直接赋值的话相当于在相同的位置上再贴一个标签，直接赋值得到的东西的地址是一样的。
  >
  > 而浅拷贝后得到的地址是不一样的。
  
  ```python
  a = {1: 'one', 2: 'two'}
  b = a.copy()
  c = a
  print(id(a))   # 2426884340288
  print(id(b))   # 2426884340480
  print(id(c))   # 2426884340288
  c[3] = 'three'
  print(c)  # {1: 'one', 2: 'two', 3: 'three'}
  print(a)  # {1: 'one', 2: 'two', 3: 'three'}
  print(b)  # {1: 'one', 2: 'two'}
  # c、a指向相同，c发生改变时，a也会发生一样的改变。而与b的指向不同，所以b不会跟着发生改变
  ```
  
  
  
- 获取全部的Key

  语法：`字典.keys()`

  结果：得到字典中<u>全部的Key(键)</u> (返回典中全部的Key（可以用变量来接收）)

  ——可以通过获取全部的key，来用for循环对key进行遍历

- 获取全部的value

  语法：`字典.values()`

  结果：得到字典中<u>全部的value(值)</u>(返回典中全部的value（可以用变量来接收）)

  ——可以通过获取全部的value，来用for循环对value进行遍历

- 把每一个键和它对应的值用括号括起来（打包成元组）

  语法：`字典.items()`

  结果：得到字典中<u>全部的(键，值)</u> (以元组的形式返回典中全部的(键，值)（可以用变量来接收）)

  ——可以通过获取全部的(键，值)，来用for循环对(键，值)进行遍历

  ```python
  # eg:
  dict1 = {}
  dict1 = dict1.fromkeys(range(10), 'good')
  print(dict1)  # {0: 'good', 1: 'good', 2: 'good', 3: 'good', 4: 'good', 5: 'good', 6: 'good', 7: 'good', 8: 'good', 9: 'good'}
  for each_key in dict1.keys():
      print(each_key, end=' ')  # 0 1 2 3 4 5 6 7 8 9
  for each_value in dict1.values():
      print(each_value, end=' ')   # good good good good good good good good good good
  for each_item in dict1.items():
      print(each_item, end=' ')  # (0, 'good') (1, 'good') (2, 'good') (3, 'good') (4, 'good') (5, 'good') (6, 'good') (7, 'good') (8, 'good')
  ```

  

- 统计字典内元素数量
  
  语法：`len(字典)`
  
  结果：返回一个整型数字（可用变量接收）

- 创建并返回一个<u>**新的字典**</u>【对原来的字典不产生影响】[不要试图用它来修改一个原有的字典，它只会直接无情地把整个字典覆盖掉]

  语法：`字典.fromkeys(s[,v])`

  （s为字典键值；v为字典**所有键**对应的初始值，可选，默认是None）

  ```python
  # eg:
  dict1 = {}
  dict2 = dict1.fromkeys((1, 2, 3))
  dict3 = dict1.fromkeys((1, 2, 3),'num')
  dict4 = dict1.fromkeys((1, 2, 3), (4, 5, 6))
  dict5 = dict3.fromkeys((1, 2, 3), (4, 5, 6))
  print(dict1)  # {}
  print(dict2)  # {1: None, 2: None, 3: None}
  print(dict3)  # {1: 'num', 2: 'num', 3: 'num'}
  print(dict4)  # {1: (4, 5, 6), 2: (4, 5, 6), 3: (4, 5, 6)}
  print(dict5)  # {1: (4, 5, 6), 2: (4, 5, 6), 3: (4, 5, 6)}
  ```
  



- 可以通过Key值来取得对应的Value

  语法：`字典[key]`

- 如果不确定是否有那个key，而想要取得它的value

  语法：`字典.get(key[,'v'])`

  [如果没有这个key：v是可选的，没写时会默认返回None；若写了’v‘，那就会返回v。

   如果有这个key：那么即使写没写’v‘，都会返回原本这个key对应的value ]

  ```python
  # eg:
  dict1 = {}
  dict1 = dict1.fromkeys(range(10), 'good')
  print(dict1.get(10)) # None
  print(dict1.get(10, 'hi')) # hi
  print(dict1.get(10)) # None
  print(dict1.get(9, 'hello')) # good
  print(dict1.get(9)) # good
  ```

- 看某个**键key(不是值value)**是否再字典里里面——还也用成员关系操作符来判断

  语法：`key in 字典`  或   `key not in 字典`

  返回一个bool类型的数据

- setdefault：与get方法类似，但是setdefault找不到对应的键时，会自动添加新的键。

  - 如果没有这个key：v是可选的，没写时会默认把None作为这个新建的键对应的value，并返回None；若写了’v‘，那就会把v当作key对应的value，并返回v。
  -  如果有这个key，或者前面刚刚创建好了这个key，即使value为None：那么即使写没写’v‘，都会返回<u>原本</u>这个key对应的value（即：v不能让原来有的value或None发生改变）

  语法：`字典.setdefault(key[,v])`

  ```python
  # eg:
  dict1 = {}
  dict1 = dict1.fromkeys(range(10), 'good')
  print(dict1.setdefault(10, 'hi')) # hi
  print(dict1.setdefault(10)) # hi
  print(dict1.setdefault(11)) # None
  print(dict1.setdefault(11, 'hii')) # None
  print(dict1)  # {0: 'good', 1: 'good', 2: 'good', 3: 'good', 4: 'good', 5: 'good', 6: 'good', 7: 'good', 8: 'good', 9: 'good', 10: 'hi', 11: None}
  print(dict1.setdefault(9, 'hello')) # good
  print(dict1.setdefault(9)) # good
  ```

  

#### 6.7.4字典的遍历

方式：（都是等效的）

1. 先获取全部的key，再对获取到的全部的key进行遍历
2. 直接对字典进行for循环，每一次循环都是直接得到key

```python
mydict={"apple":99,"peach":100,}
keys=mydict.keys() # 获取全部的key
for key in keys: # 方式1
    print(f"字典的key是：{key}")
    print(f"字典的value是：{mydict[key]}")
for key in mydict: # 方式2
    print(f"字典的key是：{key}")  # 可以直接这样子拿到字典中的key
    print(f"字典的value是：{mydict[key]}")
```

注意：字典不支持下标索引，所以不能用while循环来遍历

#### 6.7.4字典的特点

- 可以容纳多个数据
- 可以容纳不同类型的数据
- 每一份数据都是key:value键值对
- 可以通过key获取到value，key不可重复（重复会覆盖）
- 不支持下标索引
- 可以修改（增加或删除更新元素）
- 支持for循环，不支持while循环



### 6.8数据容器总结对比

#### 1.数据容器分类

1. 是否支持下标索引
   - 支持：列表、元组、字符串——序列类型
   - 不支持：集合、字典——非序列类型
2. 是否支持重复元素
   - 支持：列表、元组、字符串——序列类型
   - 不支持：集合、字典——非序列类型
3. 是否可以修改
   - 支持：列表、集合、字典
   - 不支持：元组、字符串

【回顾：序列：内容连续、有序，可使用下标索引的一类数据容器】

#### 2.数据容器特点对比

|          |               列表               |                元组                |       字符串       |                集合                 |                             字典                             |
| -------- | :------------------------------: | :--------------------------------: | :----------------: | :---------------------------------: | :----------------------------------------------------------: |
| 元素数量 |             支持多个             |              支持多个              |      支持多个      |              支持多个               |                           支持多个                           |
| 元素类型 |               任意               |                任意                |       仅字符       |                任意                 | key:value(键值对) 【  Key可以为**字典除外**的任意数据类型；Value可以为任意数据类型】 |
| 下标索引 |               支持               |                支持                |        支持        |               不支持                |                            不支持                            |
| 重复元素 |               支持               |                支持                |        支持        |               不支持                |                            不支持                            |
| 可修改性 |               支持               |               不支持               |       不支持       |                支持                 |                             支持                             |
| 数据有序 |               有序               |                有序                |        有序        |                无序                 |                             无序                             |
| 使用场景 | 可修改、可重复的一批数据记录场景 | 不可修改、可重复的一批数据记录场景 | 一串字符的记录场景 | 不可重复/去重存储的一批数据记录场景 |                 以key检索value的数据记录场景                 |

#### 3.数据容器的通用操作

- 都支持遍历：

  - 都支持for循环
  - 列表、元组、字符串支持while循环，集合、字典不支持i（不支持下标索引）

  

- 数据容器的通用统计功能：

  - `len(容器)`：统计容器的元素个数
  - `max(容器)`：返回容器的最大元素
  - `min(容器)`：返回容器的最小元素
  
  > 注意：使用max和min方法都必须要保证容器内的**数据类型是统一**的，全部都是字符/整数/浮点数/元组/……
  
  - `sum(iterable[,start=0])`：返回序列iterable（和可选参数start）的总和
  
    > 注意：不是数字类型的不能进行sum操作（eg：字符串）
  
  
  
- 容器的通用转换功能

  - `list(容器)`：将给定容器转换为列表
  - `str(容器)`：将给定容器转换为字符串
  - `tuple(容器)`：将给定容器转换为元组
  - `set(容器)`：将给定容器转换为集合

> 注意点：
>
> 1. 字典转列表或元组时，把字典的value抛弃掉，只剩下key。但字典转字符串时，所有元素都会保留下来，不会丢失掉value。
>
> 2. 字符串转列表或元组时，会将字符串中的每个字符都取出来，放到列表中作为一个单独的元素存在
>
> 3. 转字符串后，输出时会自动把双引号去掉。但是它也已经是字符串了。
>
> 4. 字符串转集合：内容会有去重处理；内容保留，但数据会无序。
>
> 5. 字典转集合：会把value丢失掉，只保留key。同时数据顺序也会乱
>
> 6. 字典可以转换成别的东西，但是，其他容器无法转换成字典（因为字典中的元素为键值对）



- 容器的通用排序功能

  语法：`sorted(容器，[reverse=Ture])`

  作用：将给定容器进行排序

  > - 该函数有2个参数：第一个参数是被排序的容器；第二个参数是一个有默认值的参数reverse（reverse默认等于false）
  > - 排序后的结果会通通变成**列表**【其实sorted函数就是会对内容进行排序，然后放到列表之中 (字典排序后就会丢失掉value)】
  > - reverse -- 排序规则：
  >   - 正向（升序）排序时，直接：`sorted(容器)`  【reverse = False 升序（默认）】
  >   - 需要反向（降序）排序时：`sorted(容器，[reverse=Ture])`



## 7.函数进阶

### 7.1函数的多返回值

一个函数要有多个返回值时，代码书写：eg:

```python
def test():
    return 1,2
x,y=test()
print(x) # 输出结果1
print(y) # 输出结果2
```

按返回值的顺序，写对应顺序的多个变量接收即可。

变量之间用**逗号**隔开，<u>支持不同类型的数据</u>return。

----

【其实，用逗号隔开多个返回值时，<u>默认是返回一个**元组**</u>。事实上是利用元组将数据打包成一个元组返回】

```python
# eg:
def back():
    return 1, 2, 4


print(back())  # (1, 2, 4)
```

当然，也可以用列表打包：

```python
# eg:
def back():
    return 1, 'my', (34, 67)


print(back())  # (1, 'my', (34, 67))
```



### 7.2函数的多种传参方式

根据使用方式上的不同，函数有4种常见参数使用方式：

1. 位置参数【默认使用形式】

   ——调用函数时根据函数定义的位置参数来传递参数（根据传入参数的位置来确定传入的是哪个参数）

   ```python
   # eg:
   def user(name,age,gender):
       print(f"名字为{name}，年龄是{age},性别是{gender}")
   user("小美"，21，"女")
   ```

   注意：传递的参数和定义的参数的顺序及个数必须一致

   

2. 关键字参数

   ——函数调用时通过“键=值”的形式传递参数

   作用：可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求（可乱序）

   ```python
   # eg:
   def user(name,age,gender):
       print(f"名字为{name}，年龄是{age},性别是{gender}")
       
   # 关键字传参可以不按照定义顺序：
   user(name="小明",gender="男",age=20)
   # 关键字参数可以和位置参数混用，位置参数必须在前，且匹配参数顺序:
   user("小明",age=20,gender="男")
   ```

   [关键字参数可以和位置参数混用，但**位置参数必须在前**，且匹配参数顺序]

   注意：函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序



3. 缺省参数/默认参数

   ——用于定义函数，为参数提供默认值，调用函数时可以不传该默认参数的值。

   【注意：所有位置参数都必须出现在默认参数前（默认值的参数必须在后面），包括函数的定义和调用】

   作用：当调用函数时没有传递参数，就会默认使用缺省参数对应的值

   ```python
   # eg:
   def user(name,age,gender="男"):
       print(f"名字为{name}，年龄是{age},性别是{gender}")
   user("Lily",20)
   user("Lily",20,"女")
   ```

   注意：函数调用时，如果为缺省参数传值则为修改默认参数值。否则就会使用缺省参数对应的值



4. 不定长参数/可变参数/收集参数 

   ——用于不确定调用的时候会传递多少个参数（不传参也可以）的场景

   作用：当调用函数，而又不确定参数个数时，可使用（参数数量随意）
   
   不定长参数的类型：
   
   1. 位置传递的不定长参数
   
      位置不定长传递以**一个 *** 标记一个形式参数args，以**元组**的形式接受参数。形式参数args所接收的参数数量是不受限的。
   
      （一般会把形参命名为args——规范）
   
      ```python
      # eg:
      def user(*args):
          print(args)
      
      user('Tom') # 返回一个元组：('Tom',)
      user('Ton',18) # 返回一个元组：('Ton',18)
      ```
   
      注意：
   
      - 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组，这就是位置传递。
   
      - 当使用不定长传递时，形式参数args会默认标记为一个元组类型。
   
      - > 当收集参数后面还要加上其他的参数，则后面的参数要用<u>关键字参数</u>来传递，否则python会把后面的参数全部列为收集参数的范畴。(建议把后面的这些参数设置为默认参数，就不容易出错)
        >
        > ```python
        > # eg:
        > def test(*params, exp):
        >        print(len(params), exp)    
        > # test(234, 'syb','ehslc', 8) # 会报错
        > test(234, 'syb','ehslc', exp = 8) # 结果：3 8     # 关键字传参
        > 
        > # 或：
        > def test(*params, exp = 8):  # 默认参数
        >        print(len(params), exp)
        > test(234, 'syb','ehslc', 8)   # 结果：4 8
        > ```
        >
        
        
   
    2. 关键字传递的不定长参数
   
      关键字不定长传递以**两个 * **标记一个形式参数kwargs（kw即keyword），以**字典**的形式接受参数。
   
      形式参数args所接收的参数数量是不受限的，但内容必须满足“**键=值**”的这种键值对形式。
   
      （一般会把形参命名为kwargs——规范）
   
      ````python
      # eg:
      def user(**kwargs):
          print(kwargs)
          
      user(name='Tom', age=18, id=110)  # 返回一个字典：{'name':'Tom','age':18,'id':110}
      ````
   
      注意：
   
      参数是“键=值”形式的情况下，所有的“键=值”都会被形参kwargs接受，同时会根据“键=值”组成字典（形参kwargs就是一个字典）



### 7.3匿名函数

#### 7.3.1函数作为参数传递

- 函数本身可以作为参数，传入另一个函数中进行使用。任何逻辑都可以自行定义作为函数传入。

- 函数传入是计算逻辑的传入，而非数据的传入。

  > 普通的数据的传入：参与计算的数据不确定，而计算逻辑确定
  >
  > 函数的传入：参与计算的数据可确定，而计算逻辑不确定（本质上是传入代码的执行逻辑）

```python
# eg:
def test(compute):
    result=compute(1,2)
    print(type(compute)) # 传入参数的类型是：<class 'function'> （函数）
    print(result)
   
def compute(x,y):
    return x,y

test(compute) # 结果：3
```



#### 7.3.2lambda匿名参数

函数的定义：

- 带有名称的函数：用def关键字定义；可以基于名称重复使用多次。
- 无名称的匿名函数：用lambda关键字定义；只可临时使用一次，无法二次使用。

-------

 匿名函数的定义语法：

```
lambda 传入参数:函数体
```

> - lambda关键字表示定义匿名函数
> - 传入参数表示匿名函数的形式参数。可以传入多个形参，形参之间用","隔开。如：`x,y`表示接收2个形式参数
> - 函数体，就是函数的执行逻辑，但要注意：**只能写一行**，无法写多行代码
> - 不用写return 语句，默认就是return的



```python
# eg:
def text(compute):
    result=compute(1,2)
    print(result)
   
text(lambda x,y:x+y)
```

```python
# eg:（小甲鱼版本）
text = lambda x, y: x + y

print(text(1, 2))  # 3
```

使用def和使用lambda，定义的函数功能完全一致，只是lambda关键字定义的函数是匿名的，无法二次使用。如果函数体要写多行代码，不可用lambda匿名函数，应使用def定义带名函数。

只写一行代码时且只使用一次函数时，用lambda更加方便简洁。



-----

小甲鱼版本:

简单来说冒号前面是函数的参数，冒号的后面是函数的返回值。lambda语句事实上是构造一个函数对象。如果要对它进行使用，只需要简单进行赋值即可。

```python
# eg:
g = lambda x, y : x * y
print(g(3, 5))  # 15
```



### 7.4两个内置函数（BIF）

#### 7.4.1  filter()函数

语法：`filter(函数名/None, iterable)`

如果第一个参数是已关闭函数的话，则将第二个可迭代数据里面的每一个元素作为函数的参数进行计算，把返回true的值筛选出来并成一个列表。如果第一个参数为None，则将第二个参数里面true的值给筛选出来。过滤器事实上就是把所有非true的内容都给过滤掉。

```python
# eg:
# 参数1为none：
vol = list(filter(None, [1, 2, 0, False, 4, 'my', True]))
print(vol)  # [1, 2, 4, 'my', True]

# 参数1为函数名：
def odd(x):
    return x % 2


vol_ = list(filter(odd, range(10)))
print(vol_)  # [1, 3, 5, 7, 9]
# 或直接：
print(list(filter(lambda x : x % 2, range(10))))  # [1, 3, 5, 7, 9]
```

#### 7.4.2  map()函数

map：在编程中指映射

有两个参数：一个是参数，一个是可迭代的序列。

作用：将序列的每一个元素作为函数的参数进行运算加工，直到可迭代序列的每一个元素都加工完毕，返回所有加工后的元素构成的新序列。

```python
# eg:
print(list(map(lambda x : x % 2, range(10))))  # [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
print(list(map(lambda x : x * 2, range(10))))  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
```



### 7.5递归函数

自己再调用自己

```python
# eg:汉诺塔
def hanoi(n, x, y, z):
    if n == 1:
        print(x, '-->', z)
    else:
        hanoi(n-1, x, z, y)
        print(x, '-->', z)
        hanoi(n-1, y, x, z)

n = int(input('请输入汉诺塔层数'))
hanoi(n, 'A', 'B', 'C')
```



## 8.文件操作

### 8.1文件的编码

编码：一种规则集合，记录了内容和二进制间进行相互转换的逻辑。

编码有许多，但最常用的是UTF-8编码

> 查看文件的编码：可以使用Windows系统自带的记事本，打开文件后，即可查看。
>
> UTF-8是目前全球通用的编码格式。除非有特殊需求，否则一律以UTF-8格式进行文件编码即可。



### 8.2文件的读取

文件操作主要包括打开、读写、关闭等操作。（可以只打开和关闭文件，不进行任何读写。）

- open（）：打开函数——打开一个已经存在的文件，或者创建一个新文件

  语法：`open(name,mode,encoding)`  

  【除了第一个参数以外，其他的都是默认参数，可以不写。mode默认是'r', encoding默认是UTF-8】
  
  > name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。
  >
  > mode：设置打开文件的模式(访问模式)：只读、写入、追加等。
  >
  > > mode常用的3种基础访问模式：
  > >
  > > r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。
  > >
  > > w：打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，原有内容会被删除。如果该文件不存在，创建新文件。
  > >
  > > a：打开一个文件用于追加。如果该文件已存在，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。
  >
  > encoding:编码格式（一般推荐使用UTF-8）
  >
  > - 注意：encoding的顺序不是第三位，所以不能用位置参数，而用**关键字参数**直接指定
  
  ```python
  # eg:
  f = open("D:\网页下载文件\how.txt", 'r',encoding="UTF-8")
  # 其实也可以只写f = open("D:\网页下载文件\how.txt")
  
  # 注意：此时的f是open函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问
  ```



- 读操作相关方法

  【注意：如果对一个文件对象进行多次读取，那么下一次会在上一次读取的结尾处接着读取（不管用的是下面哪种方法，或者混用)】

  - read()方法：读取指定长度的字节

    语法：`文件对象.read(num)`

    [num表示要从文件中读取的数据的长度（单位是字节）。如果没有传入num或传入的num为负值时，那么就表示读取文件中剩余的所有的数据，然后作为字符串返回。]

    【注意：如果对一个文件对象多次调用了read，那么下一个read会在上一个read的结尾处接着读取】

  - readlines()方法：一次性读取到文件的全部行，封装到列表中，并且返回一个列表对象，其中每一行的数据为一个元素（每一行后面的换行符“\n”也可以读取到）

    语法: `文件对象.readlines()`

  - readline()方法：一次读取一行内容【包括换行符】

    语法: `文件对象.readline()`
    
  - for循环读取文件行:（一行一行读取）【每一个临时变量，记录了文件的一行数据】
  
    （比readline、readlines方法更好，运行起来效率更高）
  
    语法：
    
    ```python
    for 临时变量 in 文件对象:
        函数体
    ```
    
    ```python
    # eg:
    for line in open("D:\网页下载文件\how.txt"):
        print(line)
    ```
    
    
  
- close() :  关闭文件对象 /解除对文件的占用

  语法：`文件对象.close()`

  > 如果不调用close, 同时程序没有停止运行，那么这个文件将一直被Python程序占用。



- with open语句：

  可打开文件，对文件进行操作，并在操作完成后自动关闭文件（可避免遗忘掉close方法）

  【关闭文件对象是必要的，但是常常被遗忘，所以可以用with open语句】

  语法：`with open(name,mode,encoding) as f:`      (f 是open函数的文件对象)

  ```python
  import time
  
  with f = open("D:\网页下载文件\how.txt")as f: 
  # 注意：此时的f是open函数的文件对象, f=open("D:\网页下载文件\how.txt", 'r',encoding="UTF-8")
      for line in f:
          print(f"每一行数据是：{line}")
       
  time.sleep(50000) # 让程序睡眠50000秒，先不继续进行
  # 可以删除文件，证明文件已经被自动关闭
  ```
  



- 返回当前在文件中的位置

  语法：`文件对象.tell()`

- 在文件中移动文件指针

  语法：`文件对象.seek(offset,from)`

  作用：从from（0代表文件起始位置，1代表当前位置，2代表文件末尾）偏移offset个字节

  

### 8.3文件的写入

- 写入文件使用open函数的“**w**”模式进行写入

  open函数的“w”模式有2个特点：

  1. 当文件不存在时，就会先创建出一个文件，再进行写入

  2. 当文件存在时，就会先把文件里面原有的内容**全部清空**，再进行写入【用写入的模式打开已存在的文件，会覆盖掉原来的文件】

     

- 写入的方法有：

  - `文件对象.write(要写入的内容str)`：写入内容str（单个字符串）
  - `文件对象.writelines(seq)`：向文件中写入字符串序列seq（多个字符串），seq应该是一个返回字符串的可迭代对象
  - `文件对象.flush()`：将内容刷新到硬盘中
  
  注意：
  
  1. 直接调用write，内容并未真正写入文件，没有真正地将内存写入硬盘中，而是会积攒在程序的内存中，称之为缓冲区
  2. 当调用flush的时候，内容才会真正写入硬盘的文件中
  3. 这样做可避免频繁的操作硬盘，导致效率下降（攒一堆之后，再一次性写进磁盘）
  4. 如果调用了close，那么不调用flush也是可以的，内容也会写入到硬盘中

```python
# eg:
# 1.打开一个不存在的文件进行写入，此时用w模式会创建一个文件
# 打开文件
f = open('python.txt', 'w',encoding="UTF-8")  # w代表写入模式
# 文件写入
f.write('hello world') # 将内容写入内存中
# 内容刷新
f.flush() # 将内存中积攒的内容真正写入到硬盘的文件中  [后面有close，这一步有没有都一样]
# 关闭文件
f.close()  # close方法是内置了flush功能的。所以如果没有调用flush但是调用了close，那内容也会写入到硬盘的文件中
```

```python
# 2.打开一个已存在的文件进行写入（假设前面已经有这个文件存在了），此时w模式会清空文件里面的全部内容
# 打开文件
f = open('python.txt', 'w',encoding="UTF-8")  
# 文件写入
f.write('hey') # 将内容写入内存中
# 内容刷新
# f.flush() # 将内存中积攒的内容真正写入到硬盘的文件中  [后面有close，这一步有没有都一样]
# 关闭文件
f.close()  # 文件内容从hello world变为hey
```



### 8.4文件的追加

【与文件的写入的操作几乎一样，只需要将w模式换为a模式即可。】

- 追加写入文件使用open函数的”**a**”模式进行写入

  open函数的“a”模式有2个特点：

  1. 当文件不存在时，就会先创建出一个文件，再进行写入
  2. 当文件存在时，就会在文件里面原有的内容后面继续写入

- 追加写入的方法（和w模式一致）

  {可以使用”\n”来写出换行符}



## 9.异常、模块与包

### 9.1异常的概念

异常就是程序运行的过程中出现了错误，也就是BUG（bug就代表软件出现错误）。

### 9.2异常的捕获

> 异常处理/捕获异常：在力所能及的范围内，对可能出现的bug，进行提前准备、提前处理。
>
> 捕获异常的作用：提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。

- 捕获常规异常

  基本语法：   （因为没有指定异常类型，所以也可以用于捕获所有异常）

  ```python
  try:
      可能会发生错误的代码  
  except:
      出现异常时要执行的代码
  ```

- 捕获指定异常

  ```python
  try:
      可能会发生错误的代码  
  except 异常类型 as 别名:  # 别名可随便起，里面记录着异常的信息（可看作一个变量，可打印输出）
      出现该异常时要执行的代码
  ```

- 捕获多个异常

  ```python
  try:
      可能会发生错误的代码
  except (异常类型1，异常类型2，...) as 别名:  # 通过一个元组，将多个异常都写到里面，用逗号隔开
      出现这些异常时要执行的代码
  ```

- 捕获所有异常  （一般用这种办法）

  ```python
  try:
      可能会发生错误的代码  
  except Exception as 别名:
      出现异常时要执行的代码
  ```

- 异常else & 异常的finally 【可选元素，可以只写其一，也可以都不写】

  基本语法：

  ```python
  try:
      可能会发生异常的代码
  except Exception as 别名:
      出现异常时要执行的代码
  else:
      未出现异常时要执行的代码
  finally:
      不管是否有异常都要执行的代码 （例如：调用close）
  ```

> - 捕获全部异常的方法：
>
>   - `except Exception as 别名:`   ——常用，一般会用
>   - `except:`    
>
> - 捕获异常时：
>
>   try和except是必须项，else和finally是可选项

-----

> 我发现一个小规律：当捕获多个或所有异常时，如果try: 后面有多个不同的错误，别名中只会记录着第一个异常的信息（输出别名时只能输出第一个异常的信息）



### 9.3异常的传递

异常是具有传递性的

```python
# eg:
def func1():
    num=1/0
   
def func2():
    func1()
   
def main():  
    try:
        func2()
    except Exception as e:
        print(f"异常信息是：{e}")   
# 异常的传递性：当函数func1中发生异常, 并且没有捕获处理这个异常的时候, 异常会传递到函数func2, 当func2也没有捕获处理这个异常的时候main函数会捕获这个异常

main()  # 调用main函数
# 利用异常具有传递性的特点, 当我们想要保证程序不会因为异常崩溃的时候, 就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都会传递到main函数中, 这样就可以确保所有的异常都会被捕获
```

不一定需要到最底层出现异常的第一句话去捕获异常，在高的层级也是可以捕获异常的，捕获了就行。

但如果所有函数都没有捕获异常，程序就会报错



### 9.4python模块

#### 9.4.1模块的导入

> 模块：是一个 Python 文件，以 .py 结尾。能定义函数，类和变量等，模块里也能包含可执行的代码。可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。
> 即：模块就是一个Python文件，里面有类、函数、变量等，可以把模块里面定义的内容直接拿过来用（要先导入模块再去使用）



- 模块在使用前需要先导入。

  导入的语法：                

  `[from 模块名] import[模块|类|变量|函数|*] [as 别名]`       —— "[ ]"为可选的意思 

   （tips：也可以通过 * 表示导入模块内的全部内容）

- 常用的组合形式：

  - import 模块名【把模块中的全部功能都导入，通过“.”来使用】

    基本语法：

    ```python
    import 模块名
    模块名.功能名  # “.”是用来确定层级关系的，通过" . "可以去找到并使用模块内部的功能（类、函数、变量等）
    ```
    ------
    ```python
    # eg:
    import time  # 导入python内置的time模块（time.py这个代码文件）
    time.sleep(5)  # 表示sleep()这个函数是属于time这个模块的，或者说属于time.py这个python文件中所写的代码 
    # 当程序执行到这条程序的时候会睡眠5秒钟
    ```
  
    
  
  - from 模块名 import 功能名    【针对模块中某一个功能去使用，可直接使用功能，不需要通过“.”来使用】
  
    基本语法：
  
    ```python
    from 模块名 import 功能名
    功能名
    ```
  
    -----
  
    ```python
    # eg:导入time模块中的sleep方法
    from time import sleep
    print("start")
    sleep(30) # 让程序睡眠30秒
    print("finish")
    ```
  
    
  
  - from 模块名 import *   【把模块中的全部功能都导入，可直接使用功能，不需要通过“.”来使用】
  
    （“ * ”表示把模块的内容全部都导进来，“ * ”代表所有、全部的意思）
  
    基本语法：
  
    ```
    from 模块名 import *
    功能名
    ```
  
    ---
  
    ```python
    # eg:导入时间模块中所有的方法
    from time import *
    print("开始")
    sleep(1)# 让程序睡眠1秒(阻塞)
    print("结束")
    ```
  
    
  
  - as定义别名 （给具体的模块或功能起别名）
  
    基本语法：
  
    - 模块定义别名：`import 模块名 as 别名`
  
    - 功能定义别名：`from 模块名 import 功能名 as 别名`
  
    ```python
    # 模块别名 eg:
    import time as t
    t.sleep(5)
    
    # 功能别名 eg:
    import time import sleep as s
    s(5)
    ```

- tips:
  - 模块的导入一般写在代码文件的开头位置
  - 通过”.”来确定层级关系
  - from可以省略，as别名也可以省略，直接只写import也可以



#### 9.4.2自定义模块

- 自定义模块只需要新建一个python文件，在Python代码文件中正常写代码即可，通过import、from关键字和导入Python内置模块一样导入即可使用。
  注意:每个Python文件都可以作为一个模块，模块的名字就是文件的名字。也就是说自定义模块名<u>必须要符合标识符命名规则</u>。

- 注意：当导入多个<u>不同模块</u>的时候，且模块内有<u>同名功能</u>.。当调用这个同名功能的时候，后导入的会覆盖先导入的，所以调用到的是后面导入的模块的功能。

- `__main__`变量  (main前后都有两个下划线)

  `if __main__ == “__main__”`表示，只有当程序是直接执行的才会进入if内部，如果是被导入的，则if无法进入

  ```python
  # eg:
  def test(a, b):
      print(a + b)
      
  # 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行test函数调用。
  # 如果没有下面的语句，那么无论是当前文件，还是其他已经导入了该模块的文件（仅仅导入模块，不调用函数），在运行的时候都会自动执行`test`函数的调用，输出结果“3”
  if __name__ == '__main__':
      test (1, 1)
  ```

- `__all__`变量  【作用在“*”上；是一个列表】

  - 作用：可以控制使用`from 模块名 import *`导入时的时候哪些功能可以被导入【如果不用*来导入，就不会受`__all__`变量影响】

  - 如果一个模块文件中有`__all__`变量，当使用`from 模块名 import *`导入时，只能导入列表中的元素

  - “ * ”代表所有，而所有来自于`__all__`变量的定义。如果没写`__all__`变量的定义，那么模块里面全部的功能都能用。如果写了，那么“ * ”能导入谁就通过它来控制了

  eg:![image-20230111001525493](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230111001525493.png)



### 9.5python包(python package)

#### 9.5.1自定义包

- 包就是一个文件夹，在该文件夹下包含了一个特殊的文件： `__init__.py `。包的作用是包含多个模块，但包的本质依然是模块。

- 如果没有“` __init__.py`”这个文件，它就是一个普通的文件夹；如果有“ `__init__.py`”这个文件，它就是一个python包。

- 导入包的方式

  1. `import 包名.模块名`

  ​       `包名.模块名.功能名`

  2. `from 包名 import *`

     `模块名.功能名`

     tips：可以通过`__all__`变量来控制`import *`

     注意：**必须**在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块<u>列表</u>

  3. `from 包名 import 模块名`

     `模块名.功能名`

  4. `from 包名.模块名 import 功能名 `

     `功能名`



#### 9.5.2安装第三方包

方法：

- 打开命令提示符程序，在里面输入：

  - pip install 包名称

  - pip install -i  https://pypi.tuna.tsinghua.edu.cn/simple 包名称 （让其连接国内的网站进行包的安装，快一些）

- 在pycharm中安装

  ![image-20230111005729577](C:\Users\86183\AppData\Roaming\Typora\typora-user-images\image-20230111005729577.png)





### 9.6os、os.path模块中关于文件、目录常用的函数使用方法

注意：因为以下这些都是os模块的函数，所以要先把模块导入（import os）后，这些函数才能使用。

os模块中关于文件、目录常用的函数使用方法：

使用语法：

`os.getcwd()`：返回当前的工作目录

`os.chdir(path)`：改变工作目录。path为要切换到的工作目录，为字符串类型(要用引号引起来)

`os.listdir(path)`：列举指定的目录名（path 为需要列出的目录路径，为字符串类型(要用引号引起来)）

`os.mkdir(path)`：创建<u>单层</u>目录路径，如该目录已存在则抛出异常  [简单来说：就是创建一个单层新文件夹（不能在新建的一个文件夹里面同时再新建内层文件夹，但可以在已经建好我文件夹里面新建文件夹 ) ]

`os.mkdirs(path)`：创建<u>多层</u>目录，如该目录已存在则抛出异常【tips：'D:/A/B'与'D:/A/C'不冲突】

`os.remove(path)`：删除<u>文件</u>

`os.rmdir(path)`：删除<u>单层目录</u>，<u>如果该目录非空则抛出异常</u>【“空”就是这个目录下边没有其他的子目录或文件】

`os.removedirs(path)`：删除<u>多层目录</u>，<u>如果目录非空则会抛出异常</u>

`os.rename(old, new)`：将文件old重命名为new

`os.system(command)`：运行系统的shell命令。command为命令，为字符串，eg：'cmd'



以下是支持路径操作中常用到的一些定义【不是函数】，支持所有平台：

`os.curdir`：指代当前目录（'.'）

`os.pardir`：指代上一级目录（'..'）

`os.sep`：输出操作系统指定的路径分隔符（Win下为'\\\\'，Linux下为'/' ）

`os.linesep`：当前平台下使用的终止换行符（Win下为'\\r\\n'，Linux下为'\n' ）

`os.name`：指代当前使用的操作系统（包括：'posix', 'nt', 'mac', 'os2', 'ce', 'java'）

----

os.path模块【不是属于os模块的】中关于路径常用的函数使用方法：

`os.path.basename(path)`：去掉







## 10.面向对象(OO)

面向对象：OO——object oriented

面向对象编程：OOP——object oriented program

面向对象分析：OOA

面向对象设计：OOD



面向对象的三大特性：封装、继承、多态

### 10.1初始对象

使用对象组织数据（类比：弄一个表格）

1. 在程序中设计表格，称为“设计类（class）”
2. 在程序中打印表格，称为“创建对象”
3. 在程序中填写表格，称为“对象属性赋值”

```python
# eg:
# 1.设计一个类（类比：设计一张登记表）
class Student:
    name = None
    gender = None
    nationality = None
    age = None


# 2.创建一个对象（类比：打印一张登记表）
stu1 = Student()  # stu1既是变量，又是对象

# 3.对象属性赋值（类比：填写表单）
stu1.name = 'cq'
stu1.gender = '女'
stu1.nationality = '中国'
stu1.age = 18

# 4.获取对象中记录的信息
print(stu1.age)  # 输出18
```



### 10.2类的成员方法

>  可以使用类去封装属性，并且基于类创建出一个个的对象去使用。

类的使用语法:【一般约定以大写字母作为类名的开头】

```python
class 类名:
    类的属性
    类的行为
```

- class是类的关键字，表明定义“类”

- 类的属性：即类中的变量，称为“成员变量”,可以用来记录数据

- 类的行为：即在类中的函数，称为“成员方法”，可以用来记录行为

  > 函数是写在类外面的；方法指的是类内部的函数。【定义在类内部的函数直接称为方法】

-----

创建类对象的方法：`对象 = 类名()`

（因为跟调用函数很像，所以为了区分，一般约定类名以大写字母开头，函数名以小写字母开头）

----

在类中定义成员函数：（与定义函数基本一致，但有细微区别）

```python
def 方法名(self，形参1，……，形参N):
    方法体
```

方法列表中有**self**关键字：

- 在成员方法定义时，它是**必须**要填写的

- 它用来表示类对象自身的意思

- 当使用类对象调用方法时，self会自动被python传入

  （尽管self关键字在参数列表中，但不占用参数位置，所以传参的时候也可以忽略它）

- 在方法内部，**想要访问类的成员变量(属性)，必须使用self**。格式：`self.成员变量`

```python
# eg:
class Student: # 定义类
    name = None
    
    def say_hi(self):
        print(f"hello,i am {self.name}")
       
    def say_hi2(self,msg):
        print(f"hello,i am {self.name},{msg}")
       
stu = Student() # 创建类对象
stu.say_hi() # 调用时无需传参
stu.say_hi2("nice to meet you") # 调用时需要传入参数msg
```



### 10.3类和对象

类是程序中的设计图纸，对象是基于图纸生产的具体实体（比喻）

面向对象的编程：使用对象进行编程，即：设计一个类，基于类去创建对象，并使用对象来完成具体的工作



### 10.4构造方法

“构造方法” 的名称：`__init__()`    （python内置方法之一）

注意：

- init前后都有2条下划线
- 构造方法也是成员方法，也必须要在参数列表中写入self
- 在构造方法内定义成员变量，需要用self关键字

----

构造方法可以实现在创建类对象（构造类）的时候：

- 会**自动执行**（即：即使不调用它，它也会自己跑起来）
- 构建类对象的传参会传递给构造方法，借此特性可以定义成员变量并赋值



```python
# eg:
class Student:
    # name = None
    # gender = None
    # age = None   # 这几行可不写

    def __init__(self, name, gender, age):  # 会自动执行
        self.name = name
        self.gender = gender
        self.age = age 
        # 这三行既有赋值的功能，又有定义的功能。所以name = None；gender = None；age = None这几行可以不写
        print("创建一个类对象")


# 创建类对象
stu = Student("cq", "nv", 18)  # 这个语句一执行，构造方法__init__就自动执行了
```



### 10.5魔术方法

魔术方法：python内置的类方法（各有各的功能）

【在python中方法名如果是`__xxxx__()`的（这是它们的命名规范），就是“魔法”方法】

常见的魔术方法有：

- `__init__()`：构造方法【可用于创建类对象的并设置初始化】

- `__str__()`：字符串方法

  （当类对象直接被转换为字符串的时候，会输出内存地址。）

  ——可以通过`__str__`方法，控制类转换为字符串的行为

  - 当使用print输出对象的时候，只要自己定义了`__str__(self)`方法，那么就会打印从在这个方法中return的数据
  - `__str__`方法需要返回一个字符串，当做这个对象的描写

  ```python
  # eg:
  class Student:
      def __init__(self, name, age):
          self.name = name
          self.age = age
  
      def __str__(self):
          return f"name:{self.name},age:{self.age}"
  
  
  stu = Student("zjl", 31)
  print(stu)                
  print(str(stu))  # 两行都是输出name:zjl,age:31
  ```

  -----

  

- `__lt__()`：小于(<)、大于(>)符号比较（严格来说是小于符号比较）

  直接对2个对象进行比较是不可以的，但是在类中实现`__lt__`方法，即可同时完成大于符号、小于符号的两种比较。

  > - 方法名：`__lt__`
  > - 传入参数：`other`  (另一个类对象)
  > - 返回值：Turn或False
  > - 内容：自行定义

  ```python
  # eg:
  class Student:
      def __init__(self, name, age):
          self.name = name
          self.age = age
  
      def __lt__(self, other):
          return self.age < other.age
  
  
  stu1 = Student("zjl", 31)
  stu2 = Student("ljj", 36)
  print(stu1 < stu2)  # Ture
  print(stu1 > stu2)  # False
  ```

  -----

  

- `__le__()`：小于等于(<=)、大于等于(>=)两种符号比较

  > - 方法名：`__le__`
  > - 传入参数：`other`  (另一个类对象)
  > - 返回值：Turn或False
  > - 内容：自行定义

  ```python
  # eg:
  class Student:
      def __init__(self, name, age):
          self.name = name
          self.age = age
  
      def __le__(self, other):
          return self.age <= other.age
  
  
  stu1 = Student("zjl", 36)
  stu2 = Student("ljj", 36)
  print(stu1 <= stu2)  # Ture
  print(stu1 >= stu2)  # Ture
  ```

  -----

  

- `__eq__()`： ==符号比较

  - 如果不实现`__eq__`方法两个对象之间可以进行等号比较，但是比较的是内存地址，即：不同对象的等号比较的结果<u>一定是False</u>（因为两个对象是独立的，内存地址肯定不同）

  - 实现了`__eq__`方法后，就可以按照自己的想法来决定两个对象是否相等了

    > - 方法名：`__eq__`
    > - 传入参数：`other`  (另一个类对象)
    > - 返回值：Turn或False
    > - 内容：自行定义

    ```python
    # eg:
    class Student:
        def __init__(self, name, age):
            self.name = name
            self.age = age
    
        def __eq__(self, other):
            return self.age == other.age
    
    
    stu1 = Student("zjl", 36)
    stu2 = Student("ljj", 36)
    print(stu1 == stu2)   # Ture
    ```



### 10.6封装

封装：将现实世界事物的属性和行为封装到类中，描述为类中的成员变量和成员方法

------

类中提供了私有成员的形式来让部分属性和行为不对使用者公开：私有成员变量和私有成员方法

定义私有成员的方式：

- 定义私有成员变量：变量名以"__"开头（2个下划线）
- 定义私有成员方法：方法名以"__"开头（2个下划线）

私有成员是不可以被用户直接使用的：

- 私有方法无法直接被类对象使用
- 私有变量无法赋值，也无法获取值

```python
# eg:
class Phone:
    __current_voltage = None

    def __keep_single_core(self):
        print("让CUU以单核模式运行")


phone = Phone()
# phone.__keep_single_core()   # 私有方法无法直接被类对象使用,会报错
# phone.__current_voltage = 33
# print(phone.__current_voltage)  # 私有变量无法赋值，也无法获取值
```

------

私有成员的访问限制：

- 无法被类对象访问，不对外开放（类对象只可以访问公开的成员变量和方法）
- 可以被类中的其他成员访问

-------

tips：

事实上python中的私有成员是“伪私有”，只是会自动对类里面的前面有两个下划线的成员进行改名，会改名为：`_类名__成员名`。

也就是在外部可以通过这种方法来访问私有成员。

```python
# eg:
class Person:
    __name = 'Tom'
    
p = Person()
print(p._Person__name)  # Tom
```





### 10.7继承

#### 10.7.1继承的基础语法

继承：从父类那里继承（复制）来成员变量和成员方法。分为单继承和多继承。

[子类创建的类对象既可以有自己的成员变量和成员方法，也可以使用父类的成员变量和成员方法。]

- 单继承：

  ```python
  class 子类名(父类名):
      类内容体
  ```

- 多继承（一个子类继承多个父类，按照从左往右依次继承）

  ```python
  class 子类名(父类1，父类2，...,父类N):
      类内容体
  ```

​        注意：多继承中，如果父类有同名的成员变量或方法，那么默认以继承顺序（从左到右）为优先级，

​                     即：**先继承的优先级高**于后继承【先继承的保留，后继承的被覆盖】

​        tips：尽量避免使用多继承，因为可能会出现不可预见的bug

----

- pass关键字：pass是<u>占位</u>语句，用来保证函数（方法）或类定义的完整性。pass表示无内容、空。

  如：当用多继承时，定义一个子类后，又不需要写新的类内容体。这时，可直接用pass代替类内容体，来补全语法

  

#### 10.7.2复写和使用父类成员

复写：子类继承父类的成员变量和成员方法后，对父类的成员变量和成员方法进行重新定义（会把父类原有的覆盖掉）

复写的语法：直接在子类中重新定义同名的变量和方法

----

调用父类同名成员（一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员）

如果需要使用被复写的父类的成员，需要特殊的调用方式：

- 方式1：通过父类名来调用父类成员
  - 调用成员变量：`父类名.成员变量`
  - 调用成员方法：`父类名.成员方法(self)`  【注意：要传self】

- 方式2：使用super()函数调用父类成员（更便捷）
  - 调用成员变量：`super().成员变量`
  - 调用成员方法：`super().成员方法()`  【注意：是空括号】

>  注意：只可以**在子类内部**调用父类的同名成员，子类的实体类对象调用默认是调用子类复写的

----

```python
class Phone:
    IMEI = None
    producer = 'IT'

    def call_by_5g(self):
        print("父类的5g通话")


class MyPhone(Phone):
    producer = 'ITHEIMA'

    def call_by_5g(self):
        # 方式一
        print(f"父类品牌是：{Phone.producer}")  # 在子类内部调用父类的同名成员
        Phone.call_by_5g(self)

        # 方式二
        print(f"父类品牌是：{super().producer}")
        super().call_by_5g()

        print("子类的5g通话")


phone = MyPhone()
phone.call_by_5g()
```



### 10.8组合

类的组合：把类的对象实例化放到一个新的类里面

组合就是指几个横向关系的类放在一起，纵向关系的类放在一起是继承，根据实际应用场景确定。简单的说，组合用于“有一个”的场景中，继承用于“是一个”的场景中。例如，水池里有一个乌龟，天上有一个鸟，地上有一个小甲鱼，这些适合使用组合。青瓜是瓜，女人是人，鲨鱼是鱼，这些就应该使用继承。

```python
class Turtle:
    def __init__(self, x):
        self.num = x


class Fish:
    def __init__(self, y):
        self.num = y


class Pool:
    def __init__(self, x, y):
        self.turtle = Turtle(x) # 实例化乌龟  # self.turtle是Turtle类实例化的对象
        self.fish = Fish(y)     # 实例化鱼

    def print_num(self):
        print("水池总共有乌龟 %d 只，小鱼 %d 只" % (self.turtle.num, self.fish.num))


pool = Pool(2, 10)
pool.print_num()  # 水池总共有乌龟 2 只，小鱼 10 只
```









### 10.9类型注解

类型注解支持：变量的类型注解、函数（方法）的形参和返回值的类型注释

作用：帮助pycharm等开发工具对代码做类型判断协助做代码提示；开发者自身做类型的备注

（当我们调用方法，进行传参时，快捷键CTRL+P弹出提示）



#### 10.9.1变量的类型注解

为变量设置类型注解的基础语法：

方法一：`变量：类型`  （常用）

```python
# eg:
# 基础类型注解：  
var_1:int = 10
var_2:float = 3.1415926
var_3:bool = Ture
var_4:str = 'it'   # 像这种显性的变量定义，一般无需注解（因为就算不写注解，也可以一眼就能明确知晓变量的类型）

# 类对象类型注解：
class Student:
    pass
stu:Student = Student()# stu是Student类类型 # 像这种无法直接看出变量类型之时，会添加变量的类型注解


# 容器类型简易注解
my_list:list = [1, 2, 3]
my_tuple:tuple = (1, 2, 3)
my_set:set = {1, 2, 3}
my_dict:dict = {'it':123}
my_str:str = 'abcd'

# 容器类型详细注解
my_list:list[int] = [1, 2, 3]
my_tuple:tuple[int, int，str, bool] = (1, 2， 'IT', Ture)
my_set:set[int] = {1, 2, 3}
my_dict:dict[str,int] = {'it':123}
```

注意：

- 元组类型设置类型详细注解，需要将每一个元素都标记出来，而集合如果相同，只需标注一个即可
- 字典类型设置详细注解，需要2个类型，第一个是key，第二个是value，中间用逗号隔开

-----

方法二：

还可以在注释中进行类型注解。语法：`# type：类型`

```python
# eg:
import json
import random


def func():
    return 10


class Student:
    pass


var1 = random.randint(1, 10)  # type:int
var2 = json.loads('{"name":"zhangsan"}')  # type:dict[str,str]

var3 = func()  # type:int    # 像这些无法直接看出变量类型之时，会添加变量的类型注解
```

-----

注意：

- 类型注解只是提示性的，并非决定性的。数据类型和注释类型无法对应也不会导致错误（即使类型注解标记错了，也不会报错）
- 为变量设置注释，显性的变量定义，一般无需注解（因为就算不写注解，也可以一眼就能明确知晓变量的类型）
- 一般无法直接看出变量类型之时，就会添加变量的类型注解



#### 10.9.2函数和方法的类型注解



#### 10.9.3Union类型



### 10.10多态

多态：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态



不同对象对同一方法响应不同的行动



python还支持一种很流行的编程模式——Mix-in（混入）



类、类对象和实例对象

当你这个类定义完的时候，类定义就变成类对象，可以直接通过“类名.属性”或者“类名.方法名()”引用或使用相关的属性或方法。类定义和类对象是捆绑在一起的。

会当作实例属性是新创建的实例对象的属性，实例属性覆盖了类属性

类中定义的属性都是静态属性

如果属性的名字跟方法相同，那么属性会把方法覆盖掉

为了避免名字上的冲突：

不要试图在一个类里面定义出所有能想到的特性和方法，应该用继承和组合机制来进行拓展

用不同的词性命名：一般属性名用名词，方法名用动词。



绑定：python严格要求方法需要有实例才能被调用，这种限制其实就是python所谓的绑定概念



- 类对象：定义的类就是类对象
- 实例对象：类对象实例化后就是实例对象
- 类属性：定义在 __init__ 外部的变量
- 实例属性：定义在__init__内部的带有self.的变量
- 类方法：定义在类对象中 且 被@classmethod 装饰的方法就是类方法
- 实例方法：定义在类对象中，且 未被@classmethod 装饰的方法就是实例方法

































